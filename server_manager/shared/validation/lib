#!/usr/bin/env bash

# Validation engine driven by shared/validation/vars.json.
# Usage:
#   validation_check <VAR_NAME> <VALUE>
#   if validation_check ...; then ... else echo "$VALIDATION_LAST_ERROR"; fi

VALIDATION_LAST_ERROR=""

_validation_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
VALIDATION_SPEC_FILE="${VALIDATION_SPEC_FILE:-${_validation_dir}/vars.json}"

validation__set_error() {
  VALIDATION_LAST_ERROR="$1"
}

validation__clear_error() {
  VALIDATION_LAST_ERROR=""
}

validation__has_jq() {
  command -v jq >/dev/null 2>&1
}

validation__is_bool() {
  case "$1" in
    true|false) return 0 ;;
    *) return 1 ;;
  esac
}

validation__is_int() {
  [[ "$1" =~ ^-?[0-9]+$ ]]
}

validation__is_number() {
  [[ "$1" =~ ^[+-]?[0-9]+([.][0-9]+)?$ ]]
}

validation__number_in_range() {
  local value min max
  value="$1"
  min="$2"
  max="$3"
  awk -v v="$value" -v min="$min" -v max="$max" 'BEGIN { exit !(v >= min && v <= max) }'
}

validation__split_csv() {
  local value
  value="$1"
  IFS=',' read -r -a _validation_split_csv_out <<<"$value"
}

validation_rule_json() {
  # Prints the rule JSON (compact) to stdout.
  # Returns: 0 ok, 2 unknown/unavailable.
  local var template field rule
  var="$1"

  validation__clear_error

  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    validation__set_error "Validation spec not found: $VALIDATION_SPEC_FILE"
    return 2
  fi
  if ! validation__has_jq; then
    validation__set_error "jq not found: cannot read validation spec"
    return 2
  fi

  rule="$(jq -c --arg var "$var" '.vars[$var] // empty' "$VALIDATION_SPEC_FILE" 2>/dev/null || true)"
  if [[ -n "$rule" && "$rule" != "null" ]]; then
    printf "%s" "$rule"
    return 0
  fi

  # Template vars follow ENV schema: <TEMPLATE>_<index>_<FIELD>
  # Example: ENSHROUDED_ROLE_0_PASSWORD
  if [[ "$var" =~ ^([A-Z0-9_]+)_[0-9]+_(.+)$ ]]; then
    template="${BASH_REMATCH[1]}"
    field="${BASH_REMATCH[2]}"
    rule="$(jq -c --arg t "$template" --arg field "$field" '.templates[$t].fields[$field] // empty' "$VALIDATION_SPEC_FILE" 2>/dev/null || true)"
    if [[ -n "$rule" && "$rule" != "null" ]]; then
      printf "%s" "$rule"
      return 0
    fi
    validation__set_error "Unknown template field: ${template}.${field}"
    return 2
  fi

  validation__set_error "No validation rule for: $var"
  return 2
}

validation_list_vars() {
  # Prints all known variable names from .vars.
  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi
  jq -r '.vars | keys[]' "$VALIDATION_SPEC_FILE" 2>/dev/null || true
}

validation_list_templates() {
  # Prints all known template names from .templates.
  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi
  jq -r '.templates | keys[]' "$VALIDATION_SPEC_FILE" 2>/dev/null || true
}

validation_list_vars_by_meta_field() {
  # Prints variable names from .vars where .meta[field] is set (non-null/non-empty).
  local field
  field="$1"

  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -r --arg f "$field" '
    .vars
    | to_entries[]
    | select(.value.meta != null)
    | select((.value.meta[$f] // null) != null)
    | select((.value.meta[$f] // "") != "")
    | .key
  ' "$VALIDATION_SPEC_FILE" 2>/dev/null || true
}

validation_list_vars_by_meta_field_ordered() {
  # Usage: validation_list_vars_by_meta_field_ordered <filter_meta_field> <order_meta_field>
  # Example:
  #   validation_list_vars_by_meta_field_ordered enshroudedMenuJsonPath menuOrder
  #
  # Sorts by .meta[order_meta_field] (numeric) and falls back to file order.
  local filter_field order_field
  filter_field="$1"
  order_field="${2:-menuOrder}"

  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -r --arg f "$filter_field" --arg o "$order_field" '
    .vars
    | to_entries
    | map(select(.value.meta != null))
    | map(select((.value.meta[$f] // null) != null))
    | map(select((.value.meta[$f] // "") != ""))
    | sort_by((.value.meta[$o] // 999999999))
    | .[].key
  ' "$VALIDATION_SPEC_FILE" 2>/dev/null || true
}

validation_var_meta_field() {
  # Usage: validation_var_meta_field <VAR_NAME> <field>
  local var field rule value
  var="$1"
  field="$2"
  rule="$(validation_rule_json "$var")" || return $?
  value="$(jq -r --arg f "$field" '.meta[$f] // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$value" == "null" ]] && value=""
  printf "%s" "$value"
}

validation_list_template_fields() {
  # Usage: validation_list_template_fields <template_name>
  # Example: validation_list_template_fields ENSHROUDED_ROLE
  local template
  template="$1"

  if [[ ! -f "$VALIDATION_SPEC_FILE" ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -r --arg t "$template" '
    .templates[$t].fields
    | to_entries
    | sort_by((.value.meta.menuOrder // 999999999))
    | .[].key
  ' "$VALIDATION_SPEC_FILE" 2>/dev/null || true
}

validation_var_type() {
  local var rule type
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  type="$(jq -r '.type // "string"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"
  printf "%s" "$type"
}

validation_var_description() {
  local var rule desc
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  desc="$(jq -r '.description // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$desc" == "null" ]] && desc=""
  printf "%s" "$desc"
}

validation_var_env_mode() {
  # Returns "hard" or "soft" if defined in the rule (empty if not set).
  local var rule mode
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  mode="$(jq -r '.envMode // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$mode" == "null" ]] && mode=""
  printf "%s" "$mode"
}

validation_var_required() {
  # Returns "true" or "false" based on the rule (false if not set).
  local var rule required
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  required="$(jq -r '.required // false' <<<"$rule" 2>/dev/null || echo "false")"
  [[ "$required" == "null" || -z "$required" ]] && required="false"
  printf "%s" "$required"
}

validation_var_allow_empty() {
  # Returns "true" or "false" based on the rule (true if not set).
  local var rule allow_empty
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  allow_empty="$(jq -r '.allowEmpty // true' <<<"$rule" 2>/dev/null || echo "true")"
  [[ "$allow_empty" == "null" || -z "$allow_empty" ]] && allow_empty="true"
  printf "%s" "$allow_empty"
}

validation_snake_to_lower_camel() {
  # Convert UPPER_SNAKE_CASE to lowerCamelCase (e.g. RESERVED_SLOTS -> reservedSlots).
  local in
  in="$1"
  echo "$in" | tr '[:upper:]' '[:lower:]' | awk -F_ '{for(i=1;i<=NF;i++){if(i==1){out=$i}else{out=out toupper(substr($i,1,1)) substr($i,2)}}}END{print out}'
}

validation_var_allowed_hint() {
  local var rule type hint min max
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?

  hint="$(jq -r '.allowed // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$hint" == "null" ]] && hint=""
  if [[ -n "$hint" ]]; then
    printf "%s" "$hint"
    return 0
  fi

  # Enum hint (string-join).
  hint="$(jq -r 'if (.enum|type) == \"array\" then \"Allowed: \" + (.enum | map(tostring) | join(\" | \")) else empty end' <<<"$rule" 2>/dev/null || true)"
  [[ "$hint" == "null" ]] && hint=""
  if [[ -n "$hint" ]]; then
    printf "%s" "$hint"
    return 0
  fi

  type="$(jq -r '.type // \"string\"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"

  case "$type" in
    bool)
      printf "%s" "Allowed: true | false"
      return 0
      ;;
    int)
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        printf "%s" "Allowed: integer $min..$max"
      elif [[ -n "$min" ]]; then
        printf "%s" "Allowed: integer >= $min"
      elif [[ -n "$max" ]]; then
        printf "%s" "Allowed: integer <= $max"
      else
        printf "%s" "Allowed: integer"
      fi
      return 0
      ;;
    number)
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        printf "%s" "Allowed: number $min..$max"
      elif [[ -n "$min" ]]; then
        printf "%s" "Allowed: number >= $min"
      elif [[ -n "$max" ]]; then
        printf "%s" "Allowed: number <= $max"
      else
        printf "%s" "Allowed: number"
      fi
      return 0
      ;;
    *)
      hint="$(jq -r '.regex // empty' <<<"$rule" 2>/dev/null || true)"
      [[ "$hint" == "null" ]] && hint=""
      if [[ -n "$hint" ]]; then
        if [[ "$hint" == "^[^\\r\\n]*$" ]]; then
          printf "%s" "Allowed: single-line string"
        else
          printf "%s" "Allowed format: $hint"
        fi
      else
        printf "%s" "String"
      fi
      return 0
      ;;
  esac
}

validation_check() {
  # Returns: 0 valid, 1 invalid, 2 unknown/unavailable.
  local var value rule required allow_empty type regex min max
  var="$1"
  value="${2-}"

  validation__clear_error
  rule="$(validation_rule_json "$var")" || return $?

  required="$(jq -r '.required // false' <<<"$rule" 2>/dev/null || echo "false")"
  [[ "$required" == "null" || -z "$required" ]] && required="false"

  allow_empty="$(jq -r '.allowEmpty // true' <<<"$rule" 2>/dev/null || echo "true")"
  [[ "$allow_empty" == "null" || -z "$allow_empty" ]] && allow_empty="true"

  if [[ -z "$value" ]]; then
    if [[ "$required" == "true" ]]; then
      validation__set_error "$var must be set"
      return 1
    fi
    if [[ "$allow_empty" == "true" ]]; then
      return 0
    fi
    validation__set_error "$var must not be empty"
    return 1
  fi

  type="$(jq -r '.type // \"string\"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"

  case "$type" in
    bool)
      if ! validation__is_bool "$value"; then
        validation__set_error "$var must be true or false (actual: $value)"
        return 1
      fi
      ;;
    int)
      if ! validation__is_int "$value"; then
        validation__set_error "$var must be an integer (actual: $value)"
        return 1
      fi
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && "$value" -lt "$min" ]]; then
        validation__set_error "$var must be an integer >= $min (actual: $value)"
        return 1
      fi
      if [[ -n "$max" && "$value" -gt "$max" ]]; then
        validation__set_error "$var must be an integer <= $max (actual: $value)"
        return 1
      fi
      ;;
    number)
      if ! validation__is_number "$value"; then
        validation__set_error "$var must be numeric (actual: $value)"
        return 1
      fi
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        if ! validation__number_in_range "$value" "$min" "$max"; then
          validation__set_error "$var must be between $min and $max (actual: $value)"
          return 1
        fi
      elif [[ -n "$min" ]]; then
        if ! awk -v v="$value" -v min="$min" 'BEGIN { exit !(v >= min) }'; then
          validation__set_error "$var must be >= $min (actual: $value)"
          return 1
        fi
      elif [[ -n "$max" ]]; then
        if ! awk -v v="$value" -v max="$max" 'BEGIN { exit !(v <= max) }'; then
          validation__set_error "$var must be <= $max (actual: $value)"
          return 1
        fi
      fi
      ;;
    *)
      regex="$(jq -r '.regex // empty' <<<"$rule" 2>/dev/null || true)"
      [[ "$regex" == "null" ]] && regex=""
      if [[ -n "$regex" ]] && ! [[ "$value" =~ $regex ]]; then
        validation__set_error "$var has invalid format (actual: $value)"
        return 1
      fi
      ;;
  esac

  # Enum constraint (after base type validation).
  if jq -e '(.enum|type) == "array"' <<<"$rule" >/dev/null 2>&1; then
    local allowed ok
    ok="false"
    while IFS= read -r allowed; do
      [[ "$value" == "$allowed" ]] && ok="true" && break
    done < <(jq -r '.enum[] | tostring' <<<"$rule" 2>/dev/null || true)

    if [[ "$ok" != "true" ]]; then
      allowed="$(jq -r '.enum | map(tostring) | join(\" \")' <<<"$rule" 2>/dev/null || true)"
      validation__set_error "$var must be one of: $allowed (actual: $value)"
      return 1
    fi
  fi

  # CSV/list constraint (after base type validation).
  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    local sep trim no_empty item_regex item item_trimmed
    sep="$(jq -r '.list.separator // \",\"' <<<"$rule" 2>/dev/null || echo ",")"
    trim="$(jq -r '.list.trim // false' <<<"$rule" 2>/dev/null || echo "false")"
    no_empty="$(jq -r '.list.itemNoEmpty // false' <<<"$rule" 2>/dev/null || echo "false")"
    item_regex="$(jq -r '.list.itemRegex // empty' <<<"$rule" 2>/dev/null || true)"
    [[ "$item_regex" == "null" ]] && item_regex=""

    # Only comma is supported right now (keeps behavior predictable in bash).
    if [[ "$sep" != "," ]]; then
      validation__set_error "$var: unsupported list separator in spec (separator: $sep)"
      return 2
    fi

    validation__split_csv "$value"
    for item in "${_validation_split_csv_out[@]}"; do
      item_trimmed="$item"
      if [[ "$trim" == "true" ]]; then
        item_trimmed="$(echo "$item_trimmed" | xargs)"
      fi

      if [[ "$no_empty" == "true" && -z "$item_trimmed" ]]; then
        validation__set_error "$var contains an empty item"
        return 1
      fi

      if [[ -n "$item_regex" && -n "$item_trimmed" ]] && ! [[ "$item_trimmed" =~ $item_regex ]]; then
        validation__set_error "$var contains invalid item: $item_trimmed"
        return 1
      fi
    done
  fi

  return 0
}
