#!/bin/bash

_validation_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

# Shared profile/path helpers are centralized in `profile`.
# shellcheck source=server_manager/jobs/profile
. "${_validation_dir}/profile"

savefile_name=""
steam_app_id=""

LOG_LEVEL_INFO=40
LOG_LEVEL_WARN=30
log_level="${LOG_LEVEL:-$LOG_LEVEL_INFO}"

init_colors() {
  if [[ "${LOG_COLOR:-}" != "true" && "${LOG_COLOR:-}" != "TRUE" ]]; then
    C_RESET=""
    C_DIM=""
    C_RED=""
    C_YELLOW=""
    C_GREEN=""
    C_MAGENTA=""
  elif [[ -t 1 ]]; then
    C_RESET=$'\033[0m'
    C_DIM=$'\033[2m'
    C_RED=$'\033[31m'
    C_YELLOW=$'\033[33m'
    C_GREEN=$'\033[32m'
    C_MAGENTA=$'\033[35m'
  else
    C_RESET=""
    C_DIM=""
    C_RED=""
    C_YELLOW=""
    C_GREEN=""
    C_MAGENTA=""
  fi
}

init_colors

info() { [[ "$log_level" -ge "$LOG_LEVEL_INFO" ]] && echo "INFO - $*" || true; }
warn() { [[ "$log_level" -ge "$LOG_LEVEL_WARN" ]] && echo "WARN - $*" || true; }
fatal() { echo "FATAL - $*" >&2; exit 1; }

# --- inlined standalone support: validation engine ---
# Validation engine driven by:
# - server_manager/env/env_server_manager.csv
# - server_manager/env/env_enshrouded_server.csv
# - server_manager/env/menu.csv (path/order mappings)
# Usage:
#   validation_check <VAR_NAME> <VALUE>
#   if validation_check ...; then ... else echo "$VALIDATION_LAST_ERROR"; fi

VALIDATION_LAST_ERROR=""
ENV_SPEC_DIR="${ENV_SPEC_DIR:-${_validation_dir}/../env}"
VALIDATION_SERVER_MANAGER_SPEC_FILE="${VALIDATION_SERVER_MANAGER_SPEC_FILE:-${ENV_SPEC_DIR}/env_server_manager.csv}"
VALIDATION_ENSHROUDED_SPEC_FILE="${VALIDATION_ENSHROUDED_SPEC_FILE:-${ENV_SPEC_DIR}/env_enshrouded_server.csv}"
VALIDATION_MENU_SPEC_FILE="${VALIDATION_MENU_SPEC_FILE:-${ENV_SPEC_DIR}/menu.csv}"

validation__set_error() {
  VALIDATION_LAST_ERROR="$1"
}

validation__clear_error() {
  VALIDATION_LAST_ERROR=""
}

validation__has_jq() {
  command -v jq >/dev/null 2>&1
}

validation__has_python3() {
  command -v python3 >/dev/null 2>&1
}

validation__csv_rows() {
  local file
  file="$1"
  [[ -f "$file" ]] || return 0
  validation__has_python3 || return 1
  python3 - "$file" <<'PY'
import csv
import sys

path = sys.argv[1]
with open(path, newline="", encoding="utf-8") as f:
    for row in csv.reader(f):
        out = []
        for cell in row:
            if cell is None or cell == "null":
                cell = ""
            cell = cell.replace("\t", " ").replace("\r", " ").replace("\n", " ")
            out.append(cell)
        print("\t".join(out))
PY
}

validation__csv_data_rows() {
  validation__csv_rows "$1" | awk 'NR > 1'
}

validation__is_bool() {
  case "$1" in
    true|false) return 0 ;;
    *) return 1 ;;
  esac
}

validation__is_int() {
  [[ "$1" =~ ^-?[0-9]+$ ]]
}

validation__is_number() {
  [[ "$1" =~ ^[+-]?[0-9]+([.][0-9]+)?$ ]]
}

validation__number_in_range() {
  local value min max
  value="$1"
  min="$2"
  max="$3"
  awk -v v="$value" -v min="$min" -v max="$max" 'BEGIN { exit !(v >= min && v <= max) }'
}

validation__split_csv() {
  local value
  value="$1"
  IFS=',' read -r -a _validation_split_csv_out <<<"$value"
}

validation__enum_to_json() {
  local enum_spec
  enum_spec="$1"
  if [[ -z "$enum_spec" ]]; then
    echo "null"
    return 0
  fi
  jq -cn --arg enum_spec "$enum_spec" '$enum_spec | split("|")'
}

validation__list_to_json() {
  local list_spec sep trim no_empty item_regex part key value
  list_spec="$1"

  if [[ -z "$list_spec" ]]; then
    echo "null"
    return 0
  fi

  sep=","
  trim="false"
  no_empty="false"
  item_regex=""

  IFS=';' read -r -a _validation_list_parts <<<"$list_spec"
  for part in "${_validation_list_parts[@]}"; do
    [[ -z "$part" ]] && continue
    key="${part%%=*}"
    value="${part#*=}"
    case "$key" in
      separator) sep="$value" ;;
      trim) trim="$value" ;;
      itemNoEmpty) no_empty="$value" ;;
      itemRegex) item_regex="$value" ;;
    esac
  done

  jq -cn \
    --arg sep "$sep" \
    --arg trim "$trim" \
    --arg no_empty "$no_empty" \
    --arg item_regex "$item_regex" \
    '{
      separator: $sep,
      trim: ($trim == "true"),
      itemNoEmpty: ($no_empty == "true")
    } + (if $item_regex == "" then {} else { itemRegex: $item_regex } end)'
}

validation__build_rule_json() {
  local env_mode val_type val_min val_max val_regex val_enum_spec val_list_spec meta_description meta_allowed
  local enum_json list_json

  env_mode="$1"
  val_type="$2"
  val_min="$3"
  val_max="$4"
  val_regex="$5"
  val_enum_spec="$6"
  val_list_spec="$7"
  meta_description="$8"
  meta_allowed="$9"

  enum_json="$(validation__enum_to_json "$val_enum_spec")"
  list_json="$(validation__list_to_json "$val_list_spec")"

  jq -cn \
    --arg env_mode "$env_mode" \
    --arg type "$val_type" \
    --arg min "$val_min" \
    --arg max "$val_max" \
    --arg regex "$val_regex" \
    --arg description "$meta_description" \
    --arg allowed "$meta_allowed" \
    --argjson enum_json "$enum_json" \
    --argjson list_json "$list_json" \
    '{
      env_mode: (if ($env_mode == "" or $env_mode == "null") then "soft" else $env_mode end),
      val_type: (if $type == "" then "string" else $type end),
      val_min: (if $min == "" then null else ($min | tonumber) end),
      val_max: (if $max == "" then null else ($max | tonumber) end),
      val_regex: (if $regex == "" then null else $regex end),
      val_enum: $enum_json,
      val_list: $list_json,
      meta_description: (if $description == "" then "" else $description end),
      meta_allowed: (if $allowed == "" then "" else $allowed end)
    }'
}

validation__rule_from_env_row() {
  local row env_name env_mode val_type val_min val_max val_regex val_enum_spec val_list_spec meta_description meta_allowed
  row="$1"
  IFS=$'\t' read -r env_name env_mode val_type val_min val_max val_regex val_enum_spec val_list_spec meta_description meta_allowed <<<"$row"
  validation__build_rule_json \
    "$env_mode" "$val_type" "$val_min" "$val_max" "$val_regex" \
    "$val_enum_spec" "$val_list_spec" "$meta_description" "$meta_allowed"
}

validation__has_spec_files() {
  [[ -f "$VALIDATION_SERVER_MANAGER_SPEC_FILE" && -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]]
}

validation__rule_for_var_from_specs() {
  local var row file
  var="$1"

  if [[ "$var" == ENSHROUDED_* ]]; then
    file="$VALIDATION_ENSHROUDED_SPEC_FILE"
  else
    file="$VALIDATION_SERVER_MANAGER_SPEC_FILE"
  fi

  validation__has_jq || return 1
  validation__has_python3 || return 1
  [[ -f "$file" ]] || return 1
  row="$(validation__csv_data_rows "$file" | awk -F'\t' -v var="$var" '$1 == var { print; exit }')"
  if [[ -n "$row" ]]; then
    validation__rule_from_env_row "$row"
    return 0
  fi

  return 1
}

validation__template_field_rule_from_specs() {
  local template field row
  template="$1"
  field="$2"

  validation__has_jq || return 1
  validation__has_python3 || return 1
  [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] || return 1
  row="$(validation__csv_data_rows "$VALIDATION_ENSHROUDED_SPEC_FILE" | awk -F'\t' -v key="${template}__${field}" '$1 == key { print; exit }')"
  if [[ -n "$row" ]]; then
    validation__rule_from_env_row "$row"
    return 0
  fi

  return 1
}

validation_rule_json() {
  # Prints the rule JSON (compact) to stdout.
  # Returns: 0 ok, 2 unknown/unavailable.
  local var template field rule
  var="$1"

  validation__clear_error

  if ! validation__has_spec_files; then
    validation__set_error "Validation spec not found (expected: $VALIDATION_SERVER_MANAGER_SPEC_FILE, $VALIDATION_ENSHROUDED_SPEC_FILE)"
    return 2
  fi
  if ! validation__has_jq; then
    validation__set_error "jq not found: cannot read validation spec"
    return 2
  fi

  rule="$(validation__rule_for_var_from_specs "$var" 2>/dev/null || true)"
  if [[ -n "$rule" && "$rule" != "null" ]]; then
    printf "%s" "$rule"
    return 0
  fi

  # Template env entries follow ENV schema: <TEMPLATE>_<index>_<FIELD>
  # Example: ENSHROUDED_ROLE_0_PASSWORD
  if [[ "$var" =~ ^([A-Z0-9_]+)_[0-9]+_(.+)$ ]]; then
    template="${BASH_REMATCH[1]}"
    field="${BASH_REMATCH[2]}"
    rule="$(validation__template_field_rule_from_specs "$template" "$field" 2>/dev/null || true)"
    if [[ -n "$rule" && "$rule" != "null" ]]; then
      printf "%s" "$rule"
      return 0
    fi
    validation__set_error "Unknown template field: ${template}.${field}"
    return 2
  fi

  validation__set_error "No validation rule for: $var"
  return 2
}

validation_list_envs() {
  # Prints all known environment names from CSV env specs.
  validation__has_python3 || return 0
  {
    [[ -f "$VALIDATION_SERVER_MANAGER_SPEC_FILE" ]] && validation__csv_data_rows "$VALIDATION_SERVER_MANAGER_SPEC_FILE" | awk -F'\t' '$1 != "" { print $1 }'
    [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] && validation__csv_data_rows "$VALIDATION_ENSHROUDED_SPEC_FILE" | awk -F'\t' '$1 != "" && $1 !~ /__/ { print $1 }'
  } | awk 'NF > 0' | sort -u || true
}

validation_list_templates() {
  # Prints all known template names.
  validation__has_python3 || return 0
  if [[ -f "$VALIDATION_MENU_SPEC_FILE" ]]; then
    validation__csv_data_rows "$VALIDATION_MENU_SPEC_FILE" | awk -F'\t' '$1 == "editor_template" && $3 != "" { print $3 }' | awk 'NF > 0' | sort -u || true
    return 0
  fi
  [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] || return 0
  validation__csv_data_rows "$VALIDATION_ENSHROUDED_SPEC_FILE" | awk -F'\t' '$1 ~ /__/ { split($1, p, "__"); if (p[1] != "") print p[1] }' | awk 'NF > 0' | sort -u || true
}

validation_list_envs_by_meta_field() {
  # Prints variable names based on menu editor mapping (menu.csv).
  local field
  field="$1"
  validation__has_python3 || return 0
  [[ -f "$VALIDATION_MENU_SPEC_FILE" ]] || return 0

  validation__csv_data_rows "$VALIDATION_MENU_SPEC_FILE" \
    | awk -F'\t' -v mf="$field" '$1 == "editor_env" && $3 == mf && $20 != "" { o=$21; if (o == "") o="999999999"; print o "\t" $17 }' \
    | sort -n -k1,1 -k2,2 \
    | cut -f2 \
    | awk 'NF > 0 && !seen[$0]++' || true
}

validation_env_meta_field() {
  # Usage: validation_env_meta_field <VAR_NAME> <field>
  # Fields are resolved from menu.csv editor rows.
  local var field value
  var="$1"
  field="$2"
  validation__has_python3 || return 0
  [[ -f "$VALIDATION_MENU_SPEC_FILE" ]] || return 0

  case "$field" in
    managerJsonPath|enshroudedJsonPath|enshroudedMenuJsonPath)
      value="$(validation__csv_data_rows "$VALIDATION_MENU_SPEC_FILE" | awk -F'\t' -v mf="$field" -v env="$var" '$1 == "editor_env" && $3 == mf && $17 == env { print $20; exit }')"
      printf "%s" "$value"
      return 0
      ;;
    menuOrder)
      value="$(validation__csv_data_rows "$VALIDATION_MENU_SPEC_FILE" | awk -F'\t' -v env="$var" '$1 == "editor_env" && $17 == env && $21 != "" { print $21; exit }')"
      printf "%s" "$value"
      return 0
      ;;
    *)
      printf "%s" ""
      return 0
      ;;
  esac
}

validation_list_template_fields() {
  # Usage: validation_list_template_fields <template_name>.
  local template
  template="$1"

  validation__has_python3 || return 0
  if [[ -f "$VALIDATION_MENU_SPEC_FILE" ]]; then
    validation__csv_data_rows "$VALIDATION_MENU_SPEC_FILE" \
      | awk -F'\t' -v t="$template" '$1 == "editor_template" && $3 == t && $19 != "" { o=$21; if (o == "") o="999999999"; print o "\t" $19 }' \
      | sort -n -k1,1 -k2,2 \
      | cut -f2 \
      | awk 'NF > 0 && !seen[$0]++' || true
    return 0
  fi

  [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] || return 0
  validation__csv_data_rows "$VALIDATION_ENSHROUDED_SPEC_FILE" | awk -F'\t' -v t="$template" '$1 ~ /__/ { split($1, p, "__"); if (p[1] == t && p[2] != "") print p[2] }' | awk 'NF > 0 && !seen[$0]++' || true
}

validation_env_type() {
  local var rule type
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  type="$(jq -r '.val_type // "string"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"
  printf "%s" "$type"
}

validation_env_description() {
  local var rule desc
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  desc="$(jq -r '.meta_description // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$desc" == "null" ]] && desc=""
  printf "%s" "$desc"
}

validation_env_mode() {
  # Returns env policy mode:
  # - hard: required ENV (no fallback)
  # - soft: optional ENV (fallback allowed)
  local var rule mode
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  mode="$(jq -r '.env_mode // "soft"' <<<"$rule" 2>/dev/null || echo "soft")"
  [[ "$mode" == "null" || -z "$mode" ]] && mode="soft"
  printf "%s" "$mode"
}

validation_snake_to_lower_camel() {
  # Convert UPPER_SNAKE_CASE to lowerCamelCase (e.g. RESERVED_SLOTS -> reservedSlots).
  local in
  in="$1"
  echo "$in" | tr '[:upper:]' '[:lower:]' | awk -F_ '{for(i=1;i<=NF;i++){if(i==1){out=$i}else{out=out toupper(substr($i,1,1)) substr($i,2)}}}END{print out}'
}

validation_env_allowed_hint() {
  local var rule hint
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?

  hint="$(jq -r '.meta_allowed // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$hint" == "null" ]] && hint=""
  printf "%s" "$hint"
  return 0
}

validation_check() {
  # Returns: 0 valid, 1 invalid, 2 unknown/unavailable.
  local var value rule mode type regex min max
  var="$1"
  value="${2-}"

  validation__clear_error
  rule="$(validation_rule_json "$var")" || return $?

  mode="$(jq -r '.env_mode // "soft"' <<<"$rule" 2>/dev/null || echo "soft")"
  [[ "$mode" == "null" || -z "$mode" ]] && mode="soft"
  if [[ "$mode" != "hard" && "$mode" != "soft" ]]; then
    validation__set_error "$var has invalid env_mode in CSV: $mode (expected: hard|soft)"
    return 2
  fi

  if [[ -z "$value" ]]; then
    if [[ "$mode" == "hard" ]]; then
      validation__set_error "$var must be set (env_mode=hard)"
      return 1
    fi
    return 0
  fi

  type="$(jq -r '.val_type // \"string\"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"

  case "$type" in
    bool)
      if ! validation__is_bool "$value"; then
        validation__set_error "$var must be true or false (actual: $value)"
        return 1
      fi
      ;;
    int)
      if ! validation__is_int "$value"; then
        validation__set_error "$var must be an integer (actual: $value)"
        return 1
      fi
      min="$(jq -r '.val_min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.val_max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && "$value" -lt "$min" ]]; then
        validation__set_error "$var must be an integer >= $min (actual: $value)"
        return 1
      fi
      if [[ -n "$max" && "$value" -gt "$max" ]]; then
        validation__set_error "$var must be an integer <= $max (actual: $value)"
        return 1
      fi
      ;;
    number)
      if ! validation__is_number "$value"; then
        validation__set_error "$var must be numeric (actual: $value)"
        return 1
      fi
      min="$(jq -r '.val_min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.val_max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        if ! validation__number_in_range "$value" "$min" "$max"; then
          validation__set_error "$var must be between $min and $max (actual: $value)"
          return 1
        fi
      elif [[ -n "$min" ]]; then
        if ! awk -v v="$value" -v min="$min" 'BEGIN { exit !(v >= min) }'; then
          validation__set_error "$var must be >= $min (actual: $value)"
          return 1
        fi
      elif [[ -n "$max" ]]; then
        if ! awk -v v="$value" -v max="$max" 'BEGIN { exit !(v <= max) }'; then
          validation__set_error "$var must be <= $max (actual: $value)"
          return 1
        fi
      fi
      ;;
    *)
      regex="$(jq -r '.val_regex // empty' <<<"$rule" 2>/dev/null || true)"
      [[ "$regex" == "null" ]] && regex=""
      if [[ -n "$regex" ]] && ! [[ "$value" =~ $regex ]]; then
        validation__set_error "$var has invalid format (actual: $value)"
        return 1
      fi
      ;;
  esac

  # Enum constraint (after base type validation).
  if jq -e '(.val_enum|type) == "array"' <<<"$rule" >/dev/null 2>&1; then
    local allowed ok
    ok="false"
    while IFS= read -r allowed; do
      [[ "$value" == "$allowed" ]] && ok="true" && break
    done < <(jq -r '.val_enum[] | tostring' <<<"$rule" 2>/dev/null || true)

    if [[ "$ok" != "true" ]]; then
      allowed="$(jq -r '.val_enum | map(tostring) | join(\" \")' <<<"$rule" 2>/dev/null || true)"
      validation__set_error "$var must be one of: $allowed (actual: $value)"
      return 1
    fi
  fi

  # CSV/list constraint (after base type validation).
  if jq -e '(.val_list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    local sep trim no_empty item_regex item item_trimmed
    sep="$(jq -r '.val_list.separator // \",\"' <<<"$rule" 2>/dev/null || echo ",")"
    trim="$(jq -r '.val_list.trim // false' <<<"$rule" 2>/dev/null || echo "false")"
    no_empty="$(jq -r '.val_list.itemNoEmpty // false' <<<"$rule" 2>/dev/null || echo "false")"
    item_regex="$(jq -r '.val_list.itemRegex // empty' <<<"$rule" 2>/dev/null || true)"
    [[ "$item_regex" == "null" ]] && item_regex=""

    # Only comma is supported right now (keeps behavior predictable in bash).
    if [[ "$sep" != "," ]]; then
      validation__set_error "$var: unsupported list separator in spec (separator: $sep)"
      return 2
    fi

    validation__split_csv "$value"
    for item in "${_validation_split_csv_out[@]}"; do
      item_trimmed="$item"
      if [[ "$trim" == "true" ]]; then
        item_trimmed="$(echo "$item_trimmed" | xargs)"
      fi

      if [[ "$no_empty" == "true" && -z "$item_trimmed" ]]; then
        validation__set_error "$var contains an empty item"
        return 1
      fi

      if [[ -n "$item_regex" && -n "$item_trimmed" ]] && ! [[ "$item_trimmed" =~ $item_regex ]]; then
        validation__set_error "$var contains invalid item: $item_trimmed"
        return 1
      fi
    done
  fi

  return 0
}

# --- inlined standalone support: profile/runtime logic ---
# Consolidated manager runtime library.
# Includes spec-apply, profile/env bootstrapping and validation helpers.


#
# Spec-driven helpers powered by server_manager/env/*.csv.
#
# Validation comes from env_server_manager.csv / env_enshrouded_server.csv.
# JSON path mappings and ordering come from menu.csv editor rows.

spec_apply__jq_set() {
  # Apply a jq transform to $file atomically (tmp+mv).
  local file tmp
  file="$1"
  shift

  tmp="$(mktemp)"
  if jq "$@" "$file" >"$tmp"; then
    mv "$tmp" "$file"
    return 0
  fi
  rm -f "$tmp" 2>/dev/null || true
  return 1
}

apply_env_to_json() {
  # Apply environment variables to a JSON file based on validation spec meta mapping.
  #
  # Usage:
  #   apply_env_to_json --file <path> --meta-field <metaField>
  #                    [--filter-prefix <jsonPathPrefix>] [--apply-empty true|false]
  #
  # Notes:
  # - By default, empty values are skipped (keeps existing behavior: env is for overrides, not "clear").
  # - If --apply-empty true is used and a var is set but empty:
  #   - list env entries are set to [] (cleared)
  #   - scalar env values are set to null
  local file meta_field filter_prefix apply_empty
  file=""
  meta_field=""
  filter_prefix=""
  apply_empty="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --meta-field)
        meta_field="${2-}"
        shift 2
        ;;
      --filter-prefix)
        filter_prefix="${2-}"
        shift 2
        ;;
      --apply-empty)
        apply_empty="${2-true}"
        shift 2
        ;;
      *)
        echo "apply_env_to_json: unknown arg: $1" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$meta_field" ]]; then
    echo "apply_env_to_json: missing --file or --meta-field" >&2
    return 1
  fi
  if [[ ! -f "$file" ]]; then
    echo "apply_env_to_json: file not found: $file" >&2
    return 1
  fi

  local any_fail var json_path rule type jq_arg value
  any_fail="false"
  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    json_path="$(validation_env_meta_field "$var" "$meta_field" 2>/dev/null || true)"
    [[ -z "$json_path" ]] && continue

    if [[ -n "$filter_prefix" ]]; then
      case "$json_path" in
        "${filter_prefix}"*) ;;
        *) continue ;;
      esac
    fi

    # Default: only apply non-empty values (preserves existing override semantics).
    if [[ "$apply_empty" == "true" ]]; then
      [[ -z "${!var+x}" ]] && continue
    else
      value="${!var-}"
      [[ -z "$value" ]] && continue
    fi

    value="${!var-}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"

    # If the value is empty but explicitly set, apply a clear behavior.
    if [[ -z "$value" ]]; then
      if [[ "$apply_empty" != "true" ]]; then
        continue
      fi
      if jq -e '(.val_list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
        if ! spec_apply__jq_set "$file" "$json_path = []"; then
          any_fail="true"
        fi
      else
        if ! spec_apply__jq_set "$file" "$json_path = null"; then
          any_fail="true"
        fi
      fi
      continue
    fi

    # List env values (CSV) -> JSON array.
    if jq -e '(.val_list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
      # Keep behavior predictable in bash: only comma separated lists are supported.
      # Spec currently only uses this for ENSHROUDED_TAGS.
      if ! spec_apply__jq_set "$file" --arg val "$value" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))"; then
        any_fail="true"
      fi
      continue
    fi

    type="$(validation_env_type "$var" 2>/dev/null || echo "string")"
    case "$type" in
      bool|int|number) jq_arg="--argjson" ;;
      *) jq_arg="--arg" ;;
    esac

    if ! spec_apply__jq_set "$file" "$jq_arg" val "$value" "$json_path = \$val"; then
      any_fail="true"
    fi
  done < <(validation_list_envs_by_meta_field "$meta_field")

  if [[ "$any_fail" == "true" ]]; then
    return 1
  fi
  return 0
}

spec_apply__template_default_object_json() {
  # Build a default JSON object for a template driven by env/*.json.
  #
  # - bool -> false
  # - int/number -> min (if set) else 0
  # - string -> "" (NAME defaults to "Default" for convenience)
  #
  # Usage: spec_apply__template_default_object_json <template_name> <env_prefix>
  local template env_prefix out first field var rule type min json_key value
  template="$1"
  env_prefix="$2"

  out="{"
  first="true"
  while IFS= read -r field; do
    [[ -z "$field" ]] && continue

    var="${env_prefix}_0_${field}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"
    [[ -z "$rule" ]] && continue

    type="$(jq -r '.val_type // "string"' <<<"$rule" 2>/dev/null || echo "string")"
    [[ "$type" == "null" || -z "$type" ]] && type="string"

    json_key="$(validation_snake_to_lower_camel "$field")"
    case "$type" in
      bool)
        value="false"
        ;;
      int|number)
        min="$(jq -r '.val_min // empty' <<<"$rule" 2>/dev/null || true)"
        [[ "$min" == "null" ]] && min=""
        if [[ -n "$min" ]]; then
          value="$min"
        else
          value="0"
        fi
        ;;
      *)
        if [[ "$field" == "NAME" ]]; then
          value="\"Default\""
        else
          value="\"\""
        fi
        ;;
    esac

    if [[ "$first" == "true" ]]; then
      first="false"
    else
      out="${out},"
    fi
    out="${out}\"${json_key}\":${value}"
  done < <(validation_list_template_fields "$template")
  out="${out}}"

  printf "%s" "$out"
}

apply_env_template_to_json_array() {
  # Apply template-driven environment variables to a JSON array of objects.
  #
  # ENV schema:
  #   <ENV_PREFIX>_<index>_<FIELD>
  #
  # The template fields/rules come from:
  #   .templates[template].fields[FIELD]
  #
  # Usage:
  #   apply_env_template_to_json_array --file <path> --template <template> --env-prefix <ENV_PREFIX> --array-path <jq_path>
  #                                   [--apply-empty true|false]
  #
  # Notes:
  # - By default, empty values are skipped (env is for overrides, not "clear").
  # - If --apply-empty true is used and a var is set but empty:
  #   - list env entries are set to [] (cleared)
  #   - scalar env values are set to null
  local file template env_prefix array_path apply_empty
  file=""
  template=""
  env_prefix=""
  array_path=""
  apply_empty="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --template)
        template="${2-}"
        shift 2
        ;;
      --env-prefix)
        env_prefix="${2-}"
        shift 2
        ;;
      --array-path)
        array_path="${2-}"
        shift 2
        ;;
      --apply-empty)
        apply_empty="${2-true}"
        shift 2
        ;;
      *)
        echo "apply_env_template_to_json_array: unknown arg: $1" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$template" || -z "$env_prefix" || -z "$array_path" ]]; then
    echo "apply_env_template_to_json_array: missing --file/--template/--env-prefix/--array-path" >&2
    return 1
  fi
  if [[ ! -f "$file" ]]; then
    echo "apply_env_template_to_json_array: file not found: $file" >&2
    return 1
  fi

  # Ensure the array exists (and is an array).
  if ! jq -e "$array_path | type == \"array\"" "$file" >/dev/null 2>&1; then
    if ! spec_apply__jq_set "$file" "$array_path = []"; then
      return 1
    fi
  fi

  # Find highest index referenced by any template env var (prefix match).
  local max_idx var idx
  max_idx="-1"
  for var in $(compgen -A variable "${env_prefix}_"); do
    if [[ "$var" =~ ^${env_prefix}_([0-9]+)_.+ ]]; then
      idx="${BASH_REMATCH[1]}"
      if [[ "$idx" =~ ^[0-9]+$ ]] && ((idx > max_idx)); then
        max_idx="$idx"
      fi
    fi
  done

  # Ensure array entries exist up to max_idx by appending a default object derived from the template.
  if ((max_idx >= 0)); then
    local default_obj i
    default_obj="$(spec_apply__template_default_object_json "$template" "$env_prefix")"
    for i in $(seq 0 "$max_idx"); do
      if ! jq -e --argjson idx "$i" "$array_path | has($idx)" "$file" >/dev/null 2>&1; then
        spec_apply__jq_set "$file" --argjson obj "$default_obj" "$array_path += [\$obj]" || true
      fi
    done
  fi

  local any_fail value field json_key json_path rule type jq_arg
  any_fail="false"

  for var in $(compgen -A variable "${env_prefix}_"); do
    if [[ ! "$var" =~ ^${env_prefix}_([0-9]+)_(.+)$ ]]; then
      continue
    fi
    idx="${BASH_REMATCH[1]}"
    field="${BASH_REMATCH[2]}"

    # Default: only apply non-empty values (preserves existing override semantics).
    if [[ "$apply_empty" == "true" ]]; then
      [[ -z "${!var+x}" ]] && continue
    else
      value="${!var-}"
      [[ -z "$value" ]] && continue
    fi

    value="${!var-}"

    # Skip unknown fields (also avoids accidental JSON injection from env var names).
    if ! validation_rule_json "$var" >/dev/null 2>&1; then
      continue
    fi

    json_key="$(validation_snake_to_lower_camel "$field")"
    json_path="${array_path}[\$idx].${json_key}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"

    # If the value is empty but explicitly set, apply a clear behavior.
    if [[ -z "$value" ]]; then
      if [[ "$apply_empty" != "true" ]]; then
        continue
      fi
      if jq -e '(.val_list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
        if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$json_path = []"; then
          any_fail="true"
        fi
      else
        if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$json_path = null"; then
          any_fail="true"
        fi
      fi
      continue
    fi

    # List env values (CSV) -> JSON array.
    if jq -e '(.val_list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
      if ! spec_apply__jq_set "$file" --argjson idx "$idx" --arg val "$value" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))"; then
        any_fail="true"
      fi
      continue
    fi

    type="$(validation_env_type "$var" 2>/dev/null || echo "string")"
    case "$type" in
      bool|int|number) jq_arg="--argjson" ;;
      *) jq_arg="--arg" ;;
    esac

    if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$jq_arg" val "$value" "$json_path = \$val"; then
      any_fail="true"
    fi
  done

  if [[ "$any_fail" == "true" ]]; then
    return 1
  fi
  return 0
}


# Profile catalog listing helpers (used by the interactive menu).
profiles_list_enshrouded() {
  local f name
  shopt -s nullglob
  for f in "$EN_PROFILE_DIR"/*_enshrouded_server.json; do
    name="$(basename "$f")"
    name="${name%_enshrouded_server.json}"
    echo "$name"
  done
  shopt -u nullglob
}

profiles_list_manager() {
  local f name
  shopt -s nullglob
  for f in "$MANAGER_PROFILE_TEMPLATE_DIR"/*_server_manager.json; do
    name="$(basename "$f")"
    name="${name%_server_manager.json}"
    echo "$name"
  done
  shopt -u nullglob
}

enshrouded_profile_resolve_from_value() {
  # Resolve an Enshrouded profile name without reading persisted selectors.
  # Usage: enshrouded_profile_resolve_from_value <name>
  local name
  name="${1-}"
  if [[ -n "$name" ]]; then
    if validation_check "EN_PROFILE" "$name"; then
      :
    else
      local rc
      rc=$?
      if [[ "$rc" -eq 1 ]]; then
        warn "Invalid enshrouded profile selector: $name (fallback: $EN_PROFILE_DEFAULT)"
        name=""
      fi
    fi
  fi
  if [[ -z "$name" ]]; then
    echo "$EN_PROFILE_DEFAULT"
    return 0
  fi
  if [[ -f "$(enshrouded_profile_path "$name")" || -f "$(enshrouded_profile_template_path "$name")" ]]; then
    echo "$name"
    return 0
  fi
  warn "Enshrouded profile not found: $name (fallback: $EN_PROFILE_DEFAULT)"
  echo "$EN_PROFILE_DEFAULT"
}

ensure_manager_profile_catalog() {
  # Seed MANAGER_PROFILE_TEMPLATE_DIR with shipped templates (copy only missing files).
  local src_dir dest_dir f dest
  src_dir="${MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR:-}"
  dest_dir="${MANAGER_PROFILE_TEMPLATE_DIR:-}"

  if [[ -z "$src_dir" || -z "$dest_dir" ]]; then
    return 0
  fi
  if [[ "$src_dir" == "$dest_dir" ]]; then
    return 0
  fi

  mkdir -p "$dest_dir" 2>/dev/null || true

  shopt -s nullglob
  for f in "$src_dir"/*_server_manager.json; do
    dest="$dest_dir/$(basename "$f")"
    if [[ -e "$dest" ]]; then
      continue
    fi
    if ! jq -e '.' "$f" >/dev/null 2>&1; then
      warn "Invalid JSON in server manager profile template: $f (skipping)"
      continue
    fi
    if cp "$f" "$dest" 2>/dev/null; then
      chmod 600 "$dest" 2>/dev/null || true
      chown enshrouded:enshrouded "$dest" 2>/dev/null || true
    else
      warn "Failed to seed Server Manager profile template: $dest"
    fi
  done
  shopt -u nullglob
}

ensure_enshrouded_profile_catalog() {
  # Seed EN_PROFILE_DIR with shipped templates (copy only missing files).
  local src_dir dest_dir f dest
  src_dir="${EN_PROFILE_TEMPLATE_DIR:-}"
  dest_dir="${EN_PROFILE_DIR:-}"

  if [[ -z "$src_dir" || -z "$dest_dir" ]]; then
    return 0
  fi
  if [[ "$src_dir" == "$dest_dir" ]]; then
    return 0
  fi

  mkdir -p "$dest_dir" 2>/dev/null || true

  shopt -s nullglob
  for f in "$src_dir"/*_enshrouded_server.json; do
    dest="$dest_dir/$(basename "$f")"
    if [[ -e "$dest" ]]; then
      continue
    fi
    if ! jq -e '.' "$f" >/dev/null 2>&1; then
      warn "Invalid JSON in enshrouded profile template: $f (skipping)"
      continue
    fi
    if cp "$f" "$dest" 2>/dev/null; then
      chmod 600 "$dest" 2>/dev/null || true
      chown enshrouded:enshrouded "$dest" 2>/dev/null || true
    else
      warn "Failed to seed Enshrouded profile template: $dest"
    fi
  done
  shopt -u nullglob
}

manager_json_get() {
  local file var path
  file="$1"
  var="$2"
  path="$(validation_env_meta_field "$var" "managerJsonPath" 2>/dev/null || true)"
  if [[ -z "$path" || ! -f "$file" ]]; then
    echo ""
    return 0
  fi
  # Keep `false` visible (jq's `// empty` treats false as empty).
  jq -r "$path | if . == null then empty else tostring end" "$file" 2>/dev/null || true
}

manager_value_is_valid() {
  local var value
  var="$1"
  value="$2"

  validation_check "$var" "$value"
}

manager_config_set() {
  local file temp_file
  file="$1"
  shift
  temp_file="$(mktemp)"
  if jq "$@" "$file" >"$temp_file"; then
    mv "$temp_file" "$file"
    chmod 600 "$file" 2>/dev/null || true
    chown enshrouded:enshrouded "$file" 2>/dev/null || true
  else
    rm -f "$temp_file"
    warn "Failed to update $file (jq error)"
  fi
}

manager_config_set_value() {
  local file var value path type
  file="$1"
  var="$2"
  value="${3-}"
  path="$(validation_env_meta_field "$var" "managerJsonPath" 2>/dev/null || true)"
  type="$(validation_env_type "$var" 2>/dev/null || true)"
  [[ -z "$type" ]] && type="string"
  if [[ -z "$path" ]]; then
    return 0
  fi
  if [[ -z "$value" ]]; then
    manager_config_set "$file" "$path = null"
    return 0
  fi
  case "$type" in
    bool|int|number)
      manager_config_set "$file" --argjson val "$value" "$path = \$val"
      ;;
    *)
      manager_config_set "$file" --arg val "$value" "$path = \$val"
      ;;
  esac
}

profiles_env_set_if_empty_validated() {
  # Set an env var only if it is currently empty/unset and the candidate is valid.
  # Usage: profiles_env_set_if_empty_validated <VAR_NAME> <candidate_value> <source_label>
  local var candidate source rc
  var="$1"
  candidate="${2-}"
  source="${3-}"

  if [[ -n "${!var-}" ]]; then
    return 0
  fi
  if [[ -z "$candidate" ]]; then
    return 0
  fi

  if validation_check "$var" "$candidate"; then
    printf -v "$var" '%s' "$candidate"
    return 0
  fi

  rc=$?
  case "$rc" in
    1)
      warn "Invalid $var in $source (actual: $candidate)"
      return 1
      ;;
    *)
      warn "Validation unavailable for $var in $source: $VALIDATION_LAST_ERROR"
      return 1
      ;;
  esac
}

manager_profile_value_for_var() {
  local profile var file value
  profile="$1"
  var="$2"
  file="$(manager_profile_path "$profile")"
  value="$(manager_json_get "$file" "$var")"
  echo "$value"
}

update_or_create_manager_config() {
  local config_file profile value env_value var created_config env_mode env_is_set
  created_config="false"

  if ! command -v jq >/dev/null 2>&1; then
    warn "jq not found: skipping server_manager.json initialization"
    return 0
  fi

  ensure_manager_paths
  profile="$(manager_profile_resolve)"

  if ! ensure_manager_profile_file "$MANAGER_PROFILE_DEFAULT"; then
    return 1
  fi
  if ! ensure_manager_profile_file "$profile"; then
    return 1
  fi

  config_file="$(manager_config_path)"
  if [[ ! -f "$config_file" ]] || ! jq -e 'type == "object"' "$config_file" >/dev/null 2>&1; then
    cp "$(manager_profile_path "$profile")" "$config_file"
    info "server_manager.json initialized from profile: $profile"
    created_config="true"
  fi

  # Ensure profile selection keys exist.
  profiles_ensure_schema || true

  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    env_mode="$(validation_env_mode "$var" 2>/dev/null)" || fatal "Validation unavailable for $var: $VALIDATION_LAST_ERROR"
    if [[ "$env_mode" != "hard" && "$env_mode" != "soft" ]]; then
      fatal "Invalid env_mode for $var: $env_mode (expected: hard|soft)"
    fi
    env_is_set="false"
    env_value=""
    if printenv "$var" >/dev/null 2>&1; then
      env_is_set="true"
      env_value="$(printenv "$var" 2>/dev/null || true)"
    fi
    value=""

    # ENV override (docker-compose/container environment) wins.
    if [[ "$env_is_set" == "true" ]]; then
      if [[ -z "$env_value" ]]; then
        fatal "ENV $var is set but empty. Empty ENV values are not allowed."
      fi
      if manager_value_is_valid "$var" "$env_value"; then
        value="$env_value"
      else
        fatal "Invalid ENV value for $var (actual: $env_value). ${VALIDATION_LAST_ERROR:-Validation failed.}"
      fi
    elif [[ "$env_mode" == "hard" ]]; then
      fatal "Missing required ENV $var (env_mode=hard). No fallback from config/profile is allowed."
    fi

    # Fallback: active config -> profile template.
    if [[ -z "$value" && "$env_mode" == "soft" ]]; then
      value="$(manager_json_get "$config_file" "$var")"
      if [[ -n "$value" ]] && ! manager_value_is_valid "$var" "$value"; then
        warn "Invalid server_manager.json value for $var (actual: $value) - resetting to profile/default (${VALIDATION_LAST_ERROR:-validation failed})"
        value=""
      fi
      if [[ -z "$value" ]]; then
        value="$(manager_profile_value_for_var "$profile" "$var")"
        if [[ -n "$value" ]] && ! manager_value_is_valid "$var" "$value"; then
          warn "Invalid manager profile value for $var (profile: $profile, actual: $value) (${VALIDATION_LAST_ERROR:-validation failed})"
          value=""
        fi
      fi
    fi

    printf -v "$var" '%s' "$value"
    if [[ -n "$value" ]]; then
      export "$var"
    fi
    manager_config_set_value "$config_file" "$var" "$value"
  done < <(validation_list_envs_by_meta_field "managerJsonPath")

  # Persist profile selection in server_manager.json (single source of truth).
  profiles_env_set_if_missing "MANAGER_PROFILE" "${MANAGER_PROFILE:-}" || true
  profiles_env_set_if_missing "EN_PROFILE" "${EN_PROFILE:-}" || true

  # Keep persisted selectors in sync with resolved profiles.
  profiles_config_set "manager" "$profile" || true
  if [[ "$created_config" == "true" ]]; then
    # On first init, allow EN_PROFILE to seed the persisted Enshrouded profile selection.
    profiles_config_set "enshrouded" "$(enshrouded_profile_resolve_from_value "${EN_PROFILE:-}")" || true
  else
    profiles_config_set "enshrouded" "$(enshrouded_profile_resolve)" || true
  fi
}

load_enshrouded_env_from_profile() {
  local profile profile_file config_file
  config_file="${install_path}/enshrouded_server.json"

  # Prefer existing runtime config as the source of truth for runtime defaults.
  # This keeps manual edits (e.g. via server menu) consistent across restarts.
  if command -v jq >/dev/null 2>&1 && [[ -f "$config_file" ]] && jq -e '.' "$config_file" >/dev/null 2>&1; then
    local var path candidate
    while IFS= read -r var; do
      [[ -z "$var" ]] && continue
      [[ -n "${!var-}" ]] && continue
      path="$(validation_env_meta_field "$var" "enshroudedJsonPath" 2>/dev/null || true)"
      [[ -z "$path" ]] && continue
      candidate="$(jq -r "$path | if . == null then empty else tostring end" "$config_file" 2>/dev/null || true)"
      profiles_env_set_if_empty_validated "$var" "$candidate" "$config_file" || true
    done < <(validation_list_envs_by_meta_field "enshroudedJsonPath")
  fi

  profile="$(enshrouded_profile_resolve)"
  # Prefer a persisted profile file in EN_PROFILE_DIR, seed from shipped templates if needed.
  ensure_enshrouded_profile_file "$profile" || true
  profile_file="$(enshrouded_profile_path "$profile")"
  if [[ ! -f "$profile_file" ]]; then
    profile_file="$(enshrouded_profile_template_path "$profile")"
  fi

  if [[ ! -f "$profile_file" ]]; then
    return 1
  fi
  if ! jq -e '.' "$profile_file" >/dev/null 2>&1; then
    return 1
  fi

  local var path candidate
  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    [[ -n "${!var-}" ]] && continue
    path="$(validation_env_meta_field "$var" "enshroudedJsonPath" 2>/dev/null || true)"
    [[ -z "$path" ]] && continue
    candidate="$(jq -r "$path | if . == null then empty else tostring end" "$profile_file" 2>/dev/null || true)"
    profiles_env_set_if_empty_validated "$var" "$candidate" "$profile_file" || true
  done < <(validation_list_envs_by_meta_field "enshroudedJsonPath")

  return 0
}

init_runtime_env() {
  # Ensure MANAGER_PROFILE_TEMPLATE_DIR contains a persistent copy of shipped Server Manager templates.
  ensure_manager_profile_catalog || true

  if ! update_or_create_manager_config; then
    fatal "Failed to initialize server_manager.json from profile"
  fi

  # Ensure EN_PROFILE_DIR contains a persistent copy of shipped Enshrouded templates.
  ensure_enshrouded_profile_catalog || true

  if ! load_enshrouded_env_from_profile; then
    fatal "Failed to load Enshrouded profile defaults"
  fi

  # Re-initialize ANSI colors after runtime env values (incl. LOG_COLOR) were loaded.
  init_colors

  savefile_name="$SAVEFILE_NAME"
  steam_app_id="$STEAM_APP_ID"
}

ensure_enshrouded_config_from_profile() {
  local profile source_profile config_file temp_file

  config_file="${install_path}/enshrouded_server.json"
  if [[ -f "$config_file" ]]; then
    return 0
  fi

  profile="$(enshrouded_profile_resolve)"
  source_profile="$(enshrouded_profile_path "$profile")"
  if [[ ! -f "$source_profile" ]]; then
    # If EN_PROFILE_DIR is empty (fresh volume), fall back to shipped templates.
    ensure_enshrouded_profile_file "$profile" || true
    source_profile="$(enshrouded_profile_path "$profile")"
  fi
  if [[ ! -f "$source_profile" ]]; then
    source_profile="$(enshrouded_profile_template_path "$profile")"
  fi
  if [[ ! -f "$source_profile" ]]; then
    warn "No enshrouded profile file found for '$profile' (searched: $EN_PROFILE_DIR, $EN_PROFILE_TEMPLATE_DIR)"
    return 1
  fi
  if ! jq -e '.' "$source_profile" >/dev/null 2>&1; then
    warn "Invalid JSON in enshrouded profile: $source_profile"
    return 1
  fi

  mkdir -p "$install_path"
  temp_file="$(mktemp)"
  if jq 'if has("bans") then . else . + {bans: []} end' "$source_profile" >"$temp_file"; then
    mv "$temp_file" "$config_file"
    chmod 600 "$config_file" 2>/dev/null || true
    chown enshrouded:enshrouded "$config_file" 2>/dev/null || true
    info "Created enshrouded_server.json from profile: $profile"
    return 0
  fi

  rm -f "$temp_file"
  warn "Failed to create enshrouded_server.json from profile: $profile"
  return 1
}


validate_template_env_values() {
  # Validate any template-driven env values declared in env/*.json (.templates).
  local template var_name value
  while IFS= read -r template; do
    [[ -z "$template" ]] && continue
    for var_name in $(compgen -A variable "${template}_" || true); do
      [[ "$var_name" =~ ^${template}_[0-9]+_ ]] || continue
      value="${!var_name-}"
      env_validate_var_from_spec "$var_name" "$value" "true" || true
    done
  done < <(validation_list_templates)
}

validate_known_env_from_spec() {
  local var_name value is_set
  while IFS= read -r var_name; do
    [[ -z "$var_name" ]] && continue
    is_set="false"
    [[ -n "${!var_name+x}" ]] && is_set="true"
    value="${!var_name-}"
    env_validate_var_from_spec "$var_name" "$value" "$is_set" || true
  done < <(validation_list_envs)
}

validate_unknown_game_settings_env_values() {
  local var_name
  if ! validation__has_spec_files || ! command -v jq >/dev/null 2>&1; then
    return 0
  fi
  for var_name in $(compgen -A variable | grep '^ENSHROUDED_GS_' || true); do
    if ! validation_rule_json "$var_name" >/dev/null 2>&1; then
      warn "Unknown game setting env var detected: $var_name"
    fi
  done
}

env_validate_var() {
  # Usage: env_validate_var <var_name> <value> [is_set]
  local var value is_set rc
  var="$1"
  value="${2-}"
  is_set="${3:-false}"

  if [[ "$is_set" == "true" && -z "$value" ]]; then
    fatal "$var is set but empty"
  fi

  if validation_check "$var" "$value"; then
    return 0
  fi
  rc=$?
  case "$rc" in
    1)
      # For both modes, invalid provided values are fatal.
      fatal "$VALIDATION_LAST_ERROR"
      ;;
    *)
      fatal "Validation unavailable for $var: $VALIDATION_LAST_ERROR"
      ;;
  esac
}

env_validate_var_from_spec() {
  # Usage: env_validate_var_from_spec <var_name> <value> [is_set]
  local var value is_set
  var="$1"
  value="${2-}"
  is_set="${3:-false}"
  env_validate_var "$var" "$value" "$is_set"
}

verify_variables() {
  validate_known_env_from_spec
  validate_template_env_values
  validate_unknown_game_settings_env_values
}

usage() {
  cat <<'EOF'
Usage:
  env-validation [verify]
  env-validation init-runtime
  env-validation check <name> <value>
EOF
}

main() {
  local command var_name var_value
  command="${1:-verify}"
  shift || true

  case "$command" in
    --help|-h|help)
      usage
      return 0
      ;;
    verify)
      [[ "$#" -eq 0 ]] || fatal "verify does not accept extra arguments"
      verify_variables
      info "ENV validation complete"
      ;;
    init-runtime)
      [[ "$#" -eq 0 ]] || fatal "init-runtime does not accept extra arguments"
      init_runtime_env
      info "Runtime initialization complete"
      ;;
    check)
      var_name="${1-}"
      var_value="${2-}"
      [[ "$#" -ge 2 ]] || fatal "Usage: env-validation check <name> <value>"
      if validation_check "$var_name" "$var_value"; then
        info "$var_name is valid"
      else
        case "$?" in
          1) fatal "$VALIDATION_LAST_ERROR" ;;
          *) fatal "Validation unavailable: $VALIDATION_LAST_ERROR" ;;
        esac
      fi
      ;;
    *)
      fatal "Unknown command: $command"
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
