#!/bin/bash
resolve_script_dir() {
  local src dir
  src="${BASH_SOURCE[0]}"
  while [[ -h "$src" ]]; do
    dir="$(cd -P "$(dirname "$src")" >/dev/null 2>&1 && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" >/dev/null 2>&1 && pwd
}

SCRIPT_DIR="$(resolve_script_dir)"
# shellcheck source=server_manager/jobs/env-validation
. "${SCRIPT_DIR}/env-validation"

# --- inlined standalone support: enshrouded runtime ---
# Consolidated Enshrouded runtime helpers (bootstrap + updater).

_enshrouded_bootstrap_shared_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

prepareEnshroudedAppFolders() {
  mkdir -p "$install_path"
}

initCrontab() {
  crontab=$(mktemp)

  if [ -n "$UPDATE_CRON" ]; then
    debug "creating cron for update checks (schedule: $UPDATE_CRON)"
    echo "$UPDATE_CRON supervisorctl start updater >/dev/null 2>&1" >>"$crontab"
  fi

  if [ -n "$BACKUP_CRON" ]; then
    debug "creating cron for backups (schedule: $BACKUP_CRON)"
    echo "$BACKUP_CRON supervisorctl start backup >/dev/null 2>&1" >>"$crontab"
  fi

  if [ -n "$RESTART_CRON" ]; then
    debug "creating cron for server restarts (schedule: $RESTART_CRON)"
    echo "$RESTART_CRON supervisorctl start restart >/dev/null 2>&1" >>"$crontab"
  fi

  crontab "$crontab"
  rm -f "$crontab"
}

prepareSteamA2sPythonLibrary() {
  pip3 install python-a2s==1.3.0 --break-system-packages
}

bootstrapHook() {
  local hook_cmd
  hook_cmd="${BOOTSTRAP_PRE_HOOK:-${BOOTSTRAP_HOOK:-}}"
  if [ -n "$hook_cmd" ]; then
    info "Running bootstrap pre hook: $hook_cmd"
    eval "$hook_cmd"
  fi
}

bootstrapPostHook() {
  if [ -n "${BOOTSTRAP_POST_HOOK:-}" ]; then
    info "Running bootstrap post hook: $BOOTSTRAP_POST_HOOK"
    eval "$BOOTSTRAP_POST_HOOK"
  fi
}

enshrouded_bootstrap_apply_top_level_env_to_config() {
  # Applies all known top-level env values (and gameSettingsPreset) based on validation spec.
  local file
  file="$1"

  if ! apply_env_to_json --file "$file" --metaField "enshroudedMenuJsonPath"; then
    warn "Failed to apply some top-level ENV values to enshrouded_server.json (jq error)"
  fi
}

updateOrCreateEnshroudedServerConfig() {
  if declare -F ensure_enshrouded_config_from_profile >/dev/null 2>&1; then
    ensure_enshrouded_config_from_profile || fatal "Failed to initialize enshrouded_server.json from profile"
  fi

  local config_file
  config_file="${install_path}/enshrouded_server.json"
  if [[ ! -e "$config_file" ]]; then
    fatal "Missing enshrouded_server.json at $config_file"
  fi

  enshrouded_bootstrap_apply_top_level_env_to_config "$config_file"

  updateUserGroupConfig
  updateGameSettingsConfig
}

updateUserGroupConfig() {
  local config_file
  config_file="${install_path}/enshrouded_server.json"
  if ! apply_env_template_to_json_array \
    --file "$config_file" \
    --template "ENSHROUDED_ROLE" \
    --envPrefix "ENSHROUDED_ROLE" \
    --arrayPath ".userGroups"; then
    warn "Failed to apply some role ENV values to enshrouded_server.json (jq error)"
  fi

  ensureUserGroupPasswords
}

generatePassword() {
  if [ -r /dev/urandom ]; then
    # Avoid `tr | head` which can emit a noisy SIGPIPE warning when `head` exits early.
    # Read bounded random bytes first, then filter and slice in bash.
    local out=""
    while [ "${#out}" -lt 12 ]; do
      out="${out}$(dd if=/dev/urandom bs=64 count=1 2>/dev/null | LC_ALL=C tr -dc 'A-Za-z0-9')"
    done
    printf '%s' "${out:0:12}"
    return 0
  fi
  date +%s%N | sha256sum | cut -c1-12
}

ensureUserGroupPasswords() {
  local count idx env_var current_password new_password

  if ! jq -e '.userGroups' ${install_path}/enshrouded_server.json >/dev/null 2>&1; then
    return 0
  fi

  count=$(jq -r '.userGroups | length' ${install_path}/enshrouded_server.json 2>/dev/null || echo 0)
  if ! [[ "$count" =~ ^[0-9]+$ ]] || [[ "$count" -le 0 ]]; then
    return 0
  fi

  for idx in $(seq 0 $((count - 1))); do
    env_var="ENSHROUDED_ROLE_${idx}_PASSWORD"
    if [[ -n "${!env_var-}" ]]; then
      continue
    fi

    current_password="$(jq -r ".userGroups[$idx].password // empty" ${install_path}/enshrouded_server.json 2>/dev/null || echo "")"
    if [[ -n "$current_password" ]]; then
      continue
    fi

    new_password="$(generatePassword)"
    if [[ -z "$new_password" ]]; then
      warn "Could not generate password for group index $idx"
      continue
    fi

    spec_apply__jq_set "${install_path}/enshrouded_server.json" --argjson group_index "$idx" --arg password "$new_password" '.userGroups[$group_index].password = $password' || warn "Failed to set generated password for group index $idx"
  done
}

updateGameSettingsConfig() {
  local config_file
  config_file="${install_path}/enshrouded_server.json"

  if ! apply_env_to_json --file "$config_file" --metaField "enshroudedJsonPath" --filterPrefix ".gameSettings."; then
    warn "Failed to apply some game settings ENV values to enshrouded_server.json (jq error)"
  fi
}


pidfile=$enshrouded_updater_pidfile
latest_version=-1

update() {
  if [ -f "$pidfile" ]; then
    info "Found existing PID file - checking process"
    checkLock $pidfile
  fi
  trap shutdown SIGINT SIGTERM
  if ! checkForUpdates; then
    if ! checkRunning "server"; then
      info "Enshrouded server is not running - starting"
      supervisorctl start server
    fi
    return
  fi
  if ! checkServerEmpty; then
    warn "Enshrouded server is not empty - update will not be performed"
    return
  fi

  doUpdate &
  enshrouded_updater_pid=$!
  echo $enshrouded_updater_pid >"$pidfile"
  wait $enshrouded_updater_pid
}

doUpdate() {
  updatePreHook
  if checkRunning "server"; then
    supervisorctl stop server
  fi
  verifyCpuMhz
  if ! downloadEnshrouded; then
    warn "Download of Enshrouded server failed - retry"
    debug "Removing $install_path/$steamapp_path"
    rm -rf $install_path/$steamapp_path

    if ! downloadEnshrouded; then
      warn "Download of Enshrouded server failed - aborting update"
      supervisorctl start server
      clearLock "$pidfile"
      return
    fi
  fi
  setCurrentVersion
  supervisorctl start server
  updatePostHook

  clearLock "$pidfile"
}

# This works around the `Unable to determine CPU Frequency. Try defining CPU_MHZ.` steamcmd issue.
verifyCpuMhz() {
  local float_regex
  local cpu_mhz
  float_regex="^([0-9]+\\.?[0-9]*)\$"
  cpu_mhz=$(grep "^cpu MHz" /proc/cpuinfo | head -1 | cut -d : -f 2 | xargs)
  if [ -n "$cpu_mhz" ] && [[ "$cpu_mhz" =~ $float_regex ]] && [ "${cpu_mhz%.*}" -gt 0 ]; then
    debug "Found CPU with $cpu_mhz MHz"
    unset CPU_MHZ
  else
    debug "Unable to determine CPU Frequency - setting a default of 1.5 GHz so steamcmd won't complain"
    export CPU_MHZ="1500.000"
  fi
}

checkServerEmpty() {
  local connected_players

  if [ "$UPDATE_CHECK_PLAYERS" == "false" ]; then
    return 0
  fi

  connected_players=$(python3 -c "
try:
    import a2s
    print(len(a2s.players(('127.0.0.1',$ENSHROUDED_QUERY_PORT))))
except Exception as e:
    print('null')
")

  debug "[checkServerEmpty] connected_players: $connected_players"
  if [ -n "$connected_players" ] && [ "$connected_players" != "null" ] && [ "$connected_players" -gt 0 ]; then
    return 1
  fi

  return 0
}

setCurrentVersion() {
  if [ "$latest_version" == "null" ] || [ "$latest_version" == "-1" ]; then
    warn "Unable to set current version - latest version is unknown"
    warn "Next update check will restart the server until version can be determined"
    return 1
  fi
  debug "[setCurrentVersion]: $latest_version"
  echo "$latest_version" >"$version_file_path"
}

updatePreHook() {
  if [ -n "$UPDATE_PRE_HOOK" ]; then
    info "Running update pre hook: $UPDATE_PRE_HOOK"
    eval "$UPDATE_PRE_HOOK"
  fi
}

updatePostHook() {
  if [ -n "$UPDATE_POST_HOOK" ]; then
    info "Running update post hook: $UPDATE_POST_HOOK"
    eval "$UPDATE_POST_HOOK"
  fi
}

shutdown() {
  debug "Received signal to shut down updater"
  clearLock "$pidfile"
}
init_runtime_env

mode="job"

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --entrypoint)
        mode="entrypoint"
        shift
        ;;
      --job)
        mode="job"
        shift
        ;;
      --help|-h)
        cat <<'EOF'
Usage:
  bootstrap [--job]
  bootstrap --entrypoint
EOF
        exit 0
        ;;
      *)
        fatal "Unknown argument: $1"
        ;;
    esac
  done
}

createFolders() {
  info "Creating server folders (save, logs, backup)"
  mkdir -p "$MANAGER_DATA_DIR" "$MANAGER_PROFILE_ROOT"

  if [[ -n "$ENSHROUDED_SAVE_DIR" ]]; then
    if [[ "$ENSHROUDED_SAVE_DIR" == /* ]]; then
      mkdir -p "$ENSHROUDED_SAVE_DIR"
    else
      mkdir -p "$install_path/$ENSHROUDED_SAVE_DIR"
    fi
  fi

  if [[ -n "$ENSHROUDED_LOG_DIR" ]]; then
    if [[ "$ENSHROUDED_LOG_DIR" == /* ]]; then
      mkdir -p "$ENSHROUDED_LOG_DIR"
    else
      mkdir -p "$install_path/$ENSHROUDED_LOG_DIR"
    fi
  fi

  if [[ -n "$BACKUP_DIR" ]]; then
    if [[ "$BACKUP_DIR" == /* ]]; then
      mkdir -p "$BACKUP_DIR"
    else
      mkdir -p "$install_path/$BACKUP_DIR"
    fi
  fi
}

applyPermissions() {
  info "Setting uid:gid of enshrouded to $PUID:$PGID"
  groupmod -g "${PGID}" -o enshrouded
  usermod -u "${PUID}" -o enshrouded
  sed -i -E "s/^(enshrouded:x):[0-9]+:[0-9]+:(.*)/\\1:$PUID:$PGID:\\2/" /etc/passwd

  chown -R enshrouded:enshrouded \
    /home/enshrouded \
    /var/run/enshrouded

  if [[ -n "${MANAGER_DATA_DIR:-}" ]] && [[ "$MANAGER_DATA_DIR" == /* ]]; then
    chown -R enshrouded:enshrouded "$MANAGER_DATA_DIR"
  fi

  if [[ -n "${MANAGER_PROFILE_ROOT:-}" ]] && [[ "$MANAGER_PROFILE_ROOT" == /* ]]; then
    chown -R enshrouded:enshrouded "$MANAGER_PROFILE_ROOT"
  fi

  if [[ "$ENSHROUDED_SAVE_DIR" == /* ]]; then
    debug "Setting permissions for $ENSHROUDED_SAVE_DIR"
    chown -R enshrouded:enshrouded "$ENSHROUDED_SAVE_DIR"
  fi

  if [[ "$ENSHROUDED_LOG_DIR" == /* ]]; then
    debug "Setting permissions for $ENSHROUDED_LOG_DIR"
    chown -R enshrouded:enshrouded "$ENSHROUDED_LOG_DIR"
  fi

  if [[ "$BACKUP_DIR" == /* ]]; then
    debug "Setting permissions for $BACKUP_DIR"
    chown -R enshrouded:enshrouded "$BACKUP_DIR"
  fi

  chgrp enshrouded /etc/supervisor/supervisord.conf
}

setupSyslog() {
  info "Setting up syslogd - logging to stdout"

  cat >"$rsyslog_conf" <<EOF
\$FileOwner root
\$FileGroup root
\$PrivDropToUser root
\$PrivDropToGroup root

\$template custom,"%timegenerated:1:10:date-rfc3339% %timegenerated:12:23:date-rfc3339% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n"
\$ActionFileDefaultTemplate custom

:msg, contains, "[session] Pending packets list is full" stop
*.*;cron,auth,authpriv.none /proc/self/fd/1          # send everything to stdout
EOF

  cat >"$supervisor_syslog_conf" <<EOF
[program:rsyslogd]
user=root
environment=HOME="/root",USER="root",LANG="en_US.UTF-8",PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
command=/usr/sbin/rsyslogd -n
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
autostart=true
autorestart=true
priority=10
EOF
}

run_entrypoint_mode() {
  verify_variables
  createFolders
  applyPermissions
  setupSyslog
  exec /usr/bin/supervisord -c /etc/supervisor/supervisord.conf
}

run_job_mode() {
  info "Running bootstrap job"
  verify_variables
  prepareEnshroudedAppFolders
  updateOrCreateEnshroudedServerConfig
  prepareSteamA2sPythonLibrary
  initCrontab
  bootstrapHook
  supervisorctl start updater
  bootstrapPostHook
  info "Bootstrap complete"
}

main() {
  parse_args "$@"
  if [[ "$mode" == "entrypoint" ]]; then
    run_entrypoint_mode
  else
    run_job_mode
  fi
}

main "$@"


