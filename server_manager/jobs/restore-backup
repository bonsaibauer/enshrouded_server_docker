#!/usr/bin/env bash

SCRIPT_DIR="$(cd -P "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" >/dev/null 2>&1 && pwd)"
# shellcheck source=server_manager/jobs/profile
. "${SCRIPT_DIR}/profile"

enshrouded_config_file="${install_path}/enshrouded_server.json"

load_runtime_values() {
  require_cmd jq
  require_cmd zip
  require_cmd tar
  require_cmd python3

  RESTORE_PRE_HOOK="$(resolve_from_env_or_manager "RESTORE_PRE_HOOK" ".restorePreHook" "")"
  RESTORE_POST_HOOK="$(resolve_from_env_or_manager "RESTORE_POST_HOOK" ".restorePostHook" "")"
  BACKUP_DIR="$(resolve_from_env_or_manager "BACKUP_DIR" ".backupDir" "backups")"
  SAVEFILE_NAME="$(resolve_from_env_or_manager "SAVEFILE_NAME" ".savefileName" "savegame")"
  ENSHROUDED_SAVE_DIR="${ENSHROUDED_SAVE_DIR:-}"
  if [[ -z "$ENSHROUDED_SAVE_DIR" && -f "$enshrouded_config_file" ]]; then
    ENSHROUDED_SAVE_DIR="$(jq -r '.saveDirectory // empty' "$enshrouded_config_file" 2>/dev/null || true)"
  fi
  [[ -n "$ENSHROUDED_SAVE_DIR" ]] || ENSHROUDED_SAVE_DIR="./savegame"
}

work_dir=""

operation="restore"
zip_path=""
restore_savegame="false"
restore_enshrouded_config="false"
restore_manager_config="false"
create_safety_backup="false"

usage() {
  cat <<'EOF'
Usage:
  restore-backup --list
  restore-backup --inspect --zip <path>
  restore-backup --zip <path> --restore <savegame|enshrouded|manager|all> [--safety-backup true|false]
EOF
}

apply_restore_selection() {
  local selector token normalized
  selector="$1"
  restore_savegame="false"
  restore_enshrouded_config="false"
  restore_manager_config="false"

  IFS=',' read -r -a _restore_tokens <<<"$selector"
  for token in "${_restore_tokens[@]}"; do
    normalized="$(echo "$token" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$normalized" in
      all)
        restore_savegame="true"
        restore_enshrouded_config="true"
        restore_manager_config="true"
        ;;
      savegame)
        restore_savegame="true"
        ;;
      enshrouded)
        restore_enshrouded_config="true"
        ;;
      manager)
        restore_manager_config="true"
        ;;
      "")
        ;;
      *)
        fatal "Unsupported restore target: $token"
        ;;
    esac
  done
}

parse_args() {
  local restore_selector
  local parsed_bool
  restore_selector=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --list)
        operation="list"
        shift
        ;;
      --inspect)
        operation="inspect"
        shift
        ;;
      --zip)
        zip_path="${2-}"
        [[ -n "$zip_path" ]] || fatal "Missing value for --zip"
        shift 2
        ;;
      --restore)
        restore_selector="${2-}"
        [[ -n "$restore_selector" ]] || fatal "Missing value for --restore"
        shift 2
        ;;
      --safety-backup)
        parsed_bool="$(parse_bool_arg "${2-}")"
        [[ -n "$parsed_bool" ]] || fatal "Invalid value for --safety-backup (expected true|false)"
        create_safety_backup="$parsed_bool"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        fatal "Unknown argument: $1"
        ;;
    esac
  done

  case "$operation" in
    list)
      [[ -z "$zip_path" ]] || fatal "--list does not accept --zip"
      [[ -z "$restore_selector" ]] || fatal "--list does not accept --restore"
      ;;
    inspect)
      [[ -n "$zip_path" ]] || fatal "Missing --zip for --inspect"
      [[ -f "$zip_path" ]] || fatal "Backup source not found: $zip_path"
      [[ -z "$restore_selector" ]] || fatal "--inspect does not accept --restore"
      ;;
    restore)
      [[ -n "$zip_path" ]] || fatal "Missing --zip"
      [[ -f "$zip_path" ]] || fatal "Backup source not found: $zip_path"
      [[ -n "$restore_selector" ]] || fatal "Missing --restore"
      apply_restore_selection "$restore_selector"
      if [[ "$restore_savegame" != "true" && "$restore_enshrouded_config" != "true" && "$restore_manager_config" != "true" ]]; then
        fatal "Missing --restore target"
      fi
      ;;
    *)
      fatal "Unsupported operation: $operation"
      ;;
  esac
}

cleanup_on_exit() {
  [[ -n "$work_dir" ]] && rm -rf "$work_dir" 2>/dev/null || true
}

trap cleanup_on_exit EXIT
trap 'exit 1' SIGINT SIGTERM

stop_server_now() {
  "${SCRIPT_DIR}/server" guard-run core_ready -- "${SCRIPT_DIR}/server" --stop-safe --shutdown-timeout 90 \
    || fatal "Failed to stop server safely before restore"
}

save_dir_resolve() {
  local dir
  dir="${ENSHROUDED_SAVE_DIR:-./savegame}"
  if [[ "$dir" == /* ]]; then
    printf "%s" "$dir"
  else
    printf "%s/%s" "$install_path" "$dir"
  fi
}

list_backup_zip_paths() {
  local backup_root
  backup_root="$(backup_dir_resolve)"
  {
    find "${backup_root}/manual" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
    find "${backup_root}/scheduled" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
  } | sort -rn | cut -f2-
}

inspect_backup_components() {
  local inspect_zip
  inspect_zip="$1"
  python3 - "$inspect_zip" <<'PY'
import pathlib
import sys
import zipfile

zip_path = pathlib.Path(sys.argv[1])
has_savegame = False
has_enshrouded = False
has_manager = False

try:
    with zipfile.ZipFile(zip_path, "r") as zf:
        for name in zf.namelist():
            if name.startswith("savegame/"):
                has_savegame = True
            elif name == "config/enshrouded_server.json":
                has_enshrouded = True
            elif name == "config/server_manager.json":
                has_manager = True
except Exception:
    pass

print(
    "true" if has_savegame else "false",
    "true" if has_enshrouded else "false",
    "true" if has_manager else "false",
)
PY
}

run_safety_backup_if_requested() {
  if [[ "$create_safety_backup" != "true" ]]; then
    return 0
  fi

  info "Creating safety backup before restore"
  create_safety_backup_archive || fatal "Safety backup failed. Restore aborted."
}

create_safety_backup_archive() {
  local stage_dir backup_root target_dir ts archive_path n
  local save_dir ens_config manager_config

  stage_dir="$(mktemp -d)"
  backup_root="$(backup_dir_resolve)"
  target_dir="${backup_root}/manual"
  save_dir="$(save_dir_resolve)"
  ens_config="${install_path}/enshrouded_server.json"
  manager_config="$(manager_config_path)"

  mkdir -p "$target_dir" 2>/dev/null || true
  chmod 700 "$backup_root" "$target_dir" 2>/dev/null || true
  chown enshrouded:enshrouded "$backup_root" "$target_dir" 2>/dev/null || true

  if [[ -d "$save_dir" ]]; then
    copy_tree "$save_dir" "${stage_dir}/savegame"
  fi
  if [[ -f "$ens_config" ]]; then
    mkdir -p "${stage_dir}/config" 2>/dev/null || true
    cp "$ens_config" "${stage_dir}/config/enshrouded_server.json"
  fi
  if [[ -f "$manager_config" ]]; then
    mkdir -p "${stage_dir}/config" 2>/dev/null || true
    cp "$manager_config" "${stage_dir}/config/server_manager.json"
  fi

  jq -n \
    --arg createdAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    --arg saveDirectory "$save_dir" \
    --arg savefileName "$SAVEFILE_NAME" \
    '{
      version: 1,
      mode: "manual",
      createdAt: $createdAt,
      saveDirectory: $saveDirectory,
      savefileName: $savefileName,
      includes: {
        savegame: true,
        enshroudedConfig: true,
        serverManagerConfig: true
      }
    }' >"${stage_dir}/manifest.json"

  ts="$(date +%Y-%m-%d_%H-%M-%S)"
  archive_path="${target_dir}/${ts}-manual-safety-backup.zip"
  if [[ -e "$archive_path" ]]; then
    n=1
    while [[ -e "${target_dir}/${ts}-manual-safety-backup-${n}.zip" ]]; do
      n=$((n + 1))
    done
    archive_path="${target_dir}/${ts}-manual-safety-backup-${n}.zip"
  fi

  (cd "$stage_dir" && zip -qr "$archive_path" .) || {
    rm -rf "$stage_dir" 2>/dev/null || true
    return 1
  }

  chmod 600 "$archive_path" 2>/dev/null || true
  chown enshrouded:enshrouded "$archive_path" 2>/dev/null || true
  rm -rf "$stage_dir" 2>/dev/null || true
  return 0
}

extract_zip() {
  work_dir="$(mktemp -d)"
  python3 - "$zip_path" "$work_dir" <<'PY'
import pathlib
import sys
import zipfile

zip_path = pathlib.Path(sys.argv[1])
dest = pathlib.Path(sys.argv[2])
dest.mkdir(parents=True, exist_ok=True)

with zipfile.ZipFile(zip_path, "r") as zf:
    for member in zf.infolist():
        target = pathlib.Path(member.filename)
        if target.is_absolute() or ".." in target.parts:
            continue
        zf.extract(member, dest)
PY
}

copy_tree() {
  local src dst
  src="$1"
  dst="$2"
  mkdir -p "$dst" 2>/dev/null || true
  (cd "$src" && tar -cf - .) | (cd "$dst" && tar -xf -)
}

restore_savegame_from_zip() {
  local save_dir
  save_dir="$(save_dir_resolve)"
  [[ -n "$save_dir" && "$save_dir" != "/" ]] || fatal "Refusing to restore into unsafe save directory: $save_dir"

  if [[ ! -d "${work_dir}/savegame" ]]; then
    fatal "Selected backup does not contain savegame data"
  fi

  mkdir -p "$save_dir" 2>/dev/null || true
  find "$save_dir" -mindepth 1 -delete 2>/dev/null || true
  copy_tree "${work_dir}/savegame" "$save_dir"

  find "$save_dir" -type f -exec chmod 600 {} + 2>/dev/null || true
  chown -R enshrouded:enshrouded "$save_dir" 2>/dev/null || true
  info "Savegame restored: $save_dir"
}

restore_json_config() {
  local src target ensure_bans tmp target_dir
  src="$1"
  target="$2"
  ensure_bans="${3:-false}"

  if [[ ! -f "$src" ]]; then
    fatal "Config source file not found in backup: $src"
  fi
  if ! jq -e 'type == "object"' "$src" >/dev/null 2>&1; then
    fatal "Invalid JSON in backup config: $src"
  fi

  target_dir="$(dirname "$target")"
  mkdir -p "$target_dir" 2>/dev/null || true
  tmp="$(mktemp "${target_dir}/.restore.XXXXXX")"
  if [[ "$ensure_bans" == "true" ]]; then
    jq 'if has("bans") then . else . + {bans: []} end' "$src" >"$tmp" || {
      rm -f "$tmp" 2>/dev/null || true
      fatal "Failed to restore config (jq error): $target"
    }
  else
    cp "$src" "$tmp" || {
      rm -f "$tmp" 2>/dev/null || true
      fatal "Failed to stage config restore: $target"
    }
  fi

  mv -f "$tmp" "$target"
  chmod 600 "$target" 2>/dev/null || true
  chown enshrouded:enshrouded "$target" 2>/dev/null || true
}

restore_enshrouded_config_from_zip() {
  local src
  src="${work_dir}/config/enshrouded_server.json"
  restore_json_config "$src" "${install_path}/enshrouded_server.json" "true"
  info "Enshrouded config restored"
}

restore_manager_config_from_zip() {
  local src target
  src="${work_dir}/config/server_manager.json"
  target="$(manager_config_path)"
  restore_json_config "$src" "$target" "false"
  profiles_ensure_schema || true
  info "Server Manager config restored"
}

main() {
  parse_args "$@"
  load_runtime_values
  info "Running restore-backup job (operation=${operation}, zip=${zip_path:-<none>})"

  case "$operation" in
    list)
      list_backup_zip_paths
      return 0
      ;;
    inspect)
      inspect_backup_components "$zip_path"
      return 0
      ;;
  esac

  "${SCRIPT_DIR}/server" hook-run --name "restore pre" --command "${RESTORE_PRE_HOOK:-}"
  stop_server_now
  run_safety_backup_if_requested

  extract_zip
  [[ "$restore_savegame" == "true" ]] && restore_savegame_from_zip
  [[ "$restore_enshrouded_config" == "true" ]] && restore_enshrouded_config_from_zip
  [[ "$restore_manager_config" == "true" ]] && restore_manager_config_from_zip

  "${SCRIPT_DIR}/server" hook-run --name "restore post" --command "${RESTORE_POST_HOOK:-}"

  info "Restore-backup job complete: $zip_path"
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
