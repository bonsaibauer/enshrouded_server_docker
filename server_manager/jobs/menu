#!/usr/bin/env bash

set -euo pipefail

MENU_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MENU_SPEC_FILE="${MENU_ROOT}/../env/env_menu.json"

# --- inlined standalone support: common runtime ---
install_path=/home/enshrouded/server
version_file_path=/home/enshrouded/current_version
steamcmd_path=/usr/bin/steamcmd
steam_app_id=""
enshrouded_binary_path=enshrouded_server.exe
savefile_name=""
steamapp_path=steamapps

# trap SIGUSR1 as it is being used to check
# for process aliveness when an existing
# pidfile is found
trap ':' USR1

# Collection of PID files
enshrouded_server_pidfile=/var/run/enshrouded/server.pid
enshrouded_updater_pidfile=/var/run/enshrouded/updater.pid
enshrouded_backup_pidfile=/var/run/enshrouded/backup.pid

# Syslog supervisor config file
supervisor_syslog_conf=/usr/local/etc/supervisor/conf.d/syslog.conf
rsyslog_conf=/etc/rsyslog.d/stdout.conf

# WINE
WINEPREFIX=/home/enshrouded/
WINEARCH=win64
WINEPATH=$install_path

# Proton
PROTONPREFIX=""

# log levels
debug=50
info=40
warn=30
error=20
critical=10
fatal=5
log_level=${log_level:-$info}

init_colors() {
  if [[ "${LOG_COLOR:-}" != "true" && "${LOG_COLOR:-}" != "TRUE" ]]; then
    C_RESET=""
    C_DIM=""
    C_RED=""
    C_YELLOW=""
    C_GREEN=""
    C_MAGENTA=""
  elif [[ -t 1 ]]; then
    C_RESET=$'\033[0m'
    C_DIM=$'\033[2m'
    C_RED=$'\033[31m'
    C_YELLOW=$'\033[33m'
    C_GREEN=$'\033[32m'
    C_MAGENTA=$'\033[35m'
  else
    C_RESET=""
    C_DIM=""
    C_RED=""
    C_YELLOW=""
    C_GREEN=""
    C_MAGENTA=""
  fi
}

level_tag() {
  case "$1" in
    DEBUG) echo "${C_DIM}DEBUG${C_RESET}" ;;
    INFO) echo "${C_GREEN}INFO${C_RESET}" ;;
    WARN) echo "${C_YELLOW}WARN${C_RESET}" ;;
    ERROR) echo "${C_RED}ERROR${C_RESET}" ;;
    CRITIAL) echo "${C_MAGENTA}CRITIAL${C_RESET}" ;;
    FATAL) echo "${C_RED}FATAL${C_RESET}" ;;
    *) echo "$1" ;;
  esac
}

init_colors

debug() { logstd $debug "$(level_tag DEBUG) - [$$] - $*"; }
info() { logstd $info "$(level_tag INFO) - $*"; }
warn() { logstd $warn "$(level_tag WARN) - $*"; }
error() { logerr $error "$(level_tag ERROR) - $*"; }
critical() { logerr $critical "$(level_tag CRITIAL) - $*"; }
fatal() {
  logerr $fatal "$(level_tag FATAL) - $*"
  exit 1
}

logstd() {
  local log_at_level
  log_at_level="$1"
  shift
  printline "$log_at_level" "$*"
}

logerr() {
  local log_at_level
  log_at_level="$1"
  shift
  printline "$log_at_level" "$*" >&2
}

printline() {
  local log_at_level
  local log_data
  log_at_level="$1"
  shift
  log_data="$*"

  if [ "$log_at_level" -le "$log_level" ]; then
    echo "$log_data"
  fi
}

checkLock() {
  local pidfile
  local predecessor_pid
  local numre
  pidfile=$1
  predecessor_pid=$(<"$pidfile")
  numre='^[0-9]+$'
  if [[ "$predecessor_pid" =~ $numre ]]; then
    debug "Sending SIGUSR1 to PID $predecessor_pid"
    if kill -USR1 "$predecessor_pid" &>/dev/null; then
      fatal "Process with PID $predecessor_pid already running - exiting"
    else
      info "Removing stale PID file and starting run"
      clearLockAndRun "$pidfile"
    fi
  else
    warn "Predecessor PID is corrupt - clearing lock and running"
    clearLockAndRun "$pidfile"
  fi
}

clearLockAndRun() {
  local pidfile
  pidfile=$1
  clearLock "$pidfile"
  main
}

clearLock() {
  local pidfile
  pidfile=$1
  info "Releasing PID file $pidfile"
  kill -SIGTERM $pidfile 2>/dev/null
  rm -f "$1"
}

checkRunning() {
  local proc
  local status
  proc=$1
  status=$(supervisorctl status "${proc}" 2>&1)
  if [[ "$status" == *RUNNING* ]]; then
    return 0
  else
    return 1
  fi
}

# --- inlined standalone support: validation engine ---
# Validation engine driven by:
# - server_manager/env/env_server_manager.json
# - server_manager/env/env_enshrouded_server.json
# Usage:
#   validation_check <VAR_NAME> <VALUE>
#   if validation_check ...; then ... else echo "$VALIDATION_LAST_ERROR"; fi

VALIDATION_LAST_ERROR=""

_validation_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
VALIDATION_SERVER_MANAGER_SPEC_FILE="${VALIDATION_SERVER_MANAGER_SPEC_FILE:-${_validation_dir}/../env/env_server_manager.json}"
VALIDATION_ENSHROUDED_SPEC_FILE="${VALIDATION_ENSHROUDED_SPEC_FILE:-${_validation_dir}/../env/env_enshrouded_server.json}"

validation__set_error() {
  VALIDATION_LAST_ERROR="$1"
}

validation__clear_error() {
  VALIDATION_LAST_ERROR=""
}

validation__has_jq() {
  command -v jq >/dev/null 2>&1
}

validation__is_bool() {
  case "$1" in
    true|false) return 0 ;;
    *) return 1 ;;
  esac
}

validation__is_int() {
  [[ "$1" =~ ^-?[0-9]+$ ]]
}

validation__is_number() {
  [[ "$1" =~ ^[+-]?[0-9]+([.][0-9]+)?$ ]]
}

validation__number_in_range() {
  local value min max
  value="$1"
  min="$2"
  max="$3"
  awk -v v="$value" -v min="$min" -v max="$max" 'BEGIN { exit !(v >= min && v <= max) }'
}

validation__split_csv() {
  local value
  value="$1"
  IFS=',' read -r -a _validation_split_csv_out <<<"$value"
}

validation__spec_files() {
  # Print available spec files, one per line.
  [[ -f "$VALIDATION_SERVER_MANAGER_SPEC_FILE" ]] && echo "$VALIDATION_SERVER_MANAGER_SPEC_FILE"
  [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] && echo "$VALIDATION_ENSHROUDED_SPEC_FILE"
}

validation__has_spec_files() {
  [[ -n "$(validation__spec_files)" ]]
}

validation__rule_for_var_from_specs() {
  local var rule
  var="$1"

  if [[ "$var" == ENSHROUDED_* ]]; then
    [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] || return 1
    rule="$(jq -c --arg var "$var" '.env[$var] // empty' "$VALIDATION_ENSHROUDED_SPEC_FILE" 2>/dev/null || true)"
  else
    [[ -f "$VALIDATION_SERVER_MANAGER_SPEC_FILE" ]] || return 1
    rule="$(jq -c --arg var "$var" '.env[$var] // empty' "$VALIDATION_SERVER_MANAGER_SPEC_FILE" 2>/dev/null || true)"
  fi

  if [[ -n "$rule" && "$rule" != "null" ]]; then
    printf "%s" "$rule"
    return 0
  fi

  return 1
}

validation__template_field_rule_from_specs() {
  local template field rule
  template="$1"
  field="$2"

  [[ -f "$VALIDATION_ENSHROUDED_SPEC_FILE" ]] || return 1
  rule="$(jq -c --arg t "$template" --arg field "$field" '.templates[$t].fields[$field] // empty' "$VALIDATION_ENSHROUDED_SPEC_FILE" 2>/dev/null || true)"
  if [[ -n "$rule" && "$rule" != "null" ]]; then
    printf "%s" "$rule"
    return 0
  fi

  return 1
}

validation_rule_json() {
  # Prints the rule JSON (compact) to stdout.
  # Returns: 0 ok, 2 unknown/unavailable.
  local var template field rule
  var="$1"

  validation__clear_error

  if ! validation__has_spec_files; then
    validation__set_error "Validation spec not found (expected: $VALIDATION_SERVER_MANAGER_SPEC_FILE, $VALIDATION_ENSHROUDED_SPEC_FILE)"
    return 2
  fi
  if ! validation__has_jq; then
    validation__set_error "jq not found: cannot read validation spec"
    return 2
  fi

  rule="$(validation__rule_for_var_from_specs "$var" 2>/dev/null || true)"
  if [[ -n "$rule" && "$rule" != "null" ]]; then
    printf "%s" "$rule"
    return 0
  fi

  # Template env entries follow ENV schema: <TEMPLATE>_<index>_<FIELD>
  # Example: ENSHROUDED_ROLE_0_PASSWORD
  if [[ "$var" =~ ^([A-Z0-9_]+)_[0-9]+_(.+)$ ]]; then
    template="${BASH_REMATCH[1]}"
    field="${BASH_REMATCH[2]}"
    rule="$(validation__template_field_rule_from_specs "$template" "$field" 2>/dev/null || true)"
    if [[ -n "$rule" && "$rule" != "null" ]]; then
      printf "%s" "$rule"
      return 0
    fi
    validation__set_error "Unknown template field: ${template}.${field}"
    return 2
  fi

  validation__set_error "No validation rule for: $var"
  return 2
}

validation_list_envs() {
  # Prints all known environment names from .env.
  local -a files
  mapfile -t files < <(validation__spec_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi
  jq -s -r '[.[].env // {} | keys[]] | unique[]' "${files[@]}" 2>/dev/null || true
}

validation_list_templates() {
  # Prints all known template names from .templates.
  local -a files
  mapfile -t files < <(validation__spec_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi
  jq -s -r '[.[].templates | keys[]?] | unique[]' "${files[@]}" 2>/dev/null || true
}

validation_list_envs_by_meta_field() {
  # Prints variable names from .env where .meta[field] is set (non-null/non-empty).
  local field
  field="$1"

  local -a files
  mapfile -t files < <(validation__spec_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -s -r --arg f "$field" '
    [.[].env // {} | to_entries[]]
    | .[]
    | select(.value.meta != null)
    | select((.value.meta[$f] // null) != null)
    | select((.value.meta[$f] // "") != "")
    | .key
  ' "${files[@]}" 2>/dev/null | sort -u || true
}

validation_list_envs_by_meta_field_ordered() {
  # Usage: validation_list_envs_by_meta_field_ordered <filter_meta_field> <order_meta_field>
  # Example:
  #   validation_list_envs_by_meta_field_ordered enshroudedMenuJsonPath menuOrder
  #
  # Sorts by .meta[order_meta_field] (numeric) and falls back to file order.
  local filter_field order_field
  filter_field="$1"
  order_field="${2:-menuOrder}"

  local -a files
  mapfile -t files < <(validation__spec_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -s -r --arg f "$filter_field" --arg o "$order_field" '
    [.[].env // {} | to_entries[]]
    | map(select(.value.meta != null))
    | map(select((.value.meta[$f] // null) != null))
    | map(select((.value.meta[$f] // "") != ""))
    | sort_by((.value.meta[$o] // 999999999))
    | .[].key
  ' "${files[@]}" 2>/dev/null | awk '!seen[$0]++' || true
}

validation_env_meta_field() {
  # Usage: validation_env_meta_field <VAR_NAME> <field>
  local var field rule value
  var="$1"
  field="$2"
  rule="$(validation_rule_json "$var")" || return $?
  value="$(jq -r --arg f "$field" '.meta[$f] // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$value" == "null" ]] && value=""
  printf "%s" "$value"
}

validation_list_template_fields() {
  # Usage: validation_list_template_fields <template_name>
  # Example: validation_list_template_fields ENSHROUDED_ROLE
  local template
  template="$1"

  local -a files
  mapfile -t files < <(validation__spec_files)
  if [[ "${#files[@]}" -eq 0 ]]; then
    return 0
  fi
  if ! validation__has_jq; then
    return 0
  fi

  jq -s -r --arg t "$template" '
    [.[].templates[$t].fields | to_entries[]?]
    | sort_by((.value.meta.menuOrder // 999999999))
    | .[].key
  ' "${files[@]}" 2>/dev/null | awk '!seen[$0]++' || true
}

validation_env_type() {
  local var rule type
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  type="$(jq -r '.type // "string"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"
  printf "%s" "$type"
}

validation_env_description() {
  local var rule desc
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  desc="$(jq -r '.description // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$desc" == "null" ]] && desc=""
  printf "%s" "$desc"
}

validation_env_mode() {
  # Returns "hard" or "soft" if defined in the rule (empty if not set).
  local var rule mode
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  mode="$(jq -r '.envMode // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$mode" == "null" ]] && mode=""
  printf "%s" "$mode"
}

validation_env_required() {
  # Returns "true" or "false" based on the rule (false if not set).
  local var rule required
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  required="$(jq -r '.required // false' <<<"$rule" 2>/dev/null || echo "false")"
  [[ "$required" == "null" || -z "$required" ]] && required="false"
  printf "%s" "$required"
}

validation_env_allow_empty() {
  # Returns "true" or "false" based on the rule (true if not set).
  local var rule allow_empty
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?
  allow_empty="$(jq -r '.allowEmpty // true' <<<"$rule" 2>/dev/null || echo "true")"
  [[ "$allow_empty" == "null" || -z "$allow_empty" ]] && allow_empty="true"
  printf "%s" "$allow_empty"
}

validation_snake_to_lower_camel() {
  # Convert UPPER_SNAKE_CASE to lowerCamelCase (e.g. RESERVED_SLOTS -> reservedSlots).
  local in
  in="$1"
  echo "$in" | tr '[:upper:]' '[:lower:]' | awk -F_ '{for(i=1;i<=NF;i++){if(i==1){out=$i}else{out=out toupper(substr($i,1,1)) substr($i,2)}}}END{print out}'
}

validation_env_allowed_hint() {
  local var rule type hint min max
  var="$1"
  rule="$(validation_rule_json "$var")" || return $?

  hint="$(jq -r '.allowed // empty' <<<"$rule" 2>/dev/null || true)"
  [[ "$hint" == "null" ]] && hint=""
  if [[ -n "$hint" ]]; then
    printf "%s" "$hint"
    return 0
  fi

  # Enum hint (string-join).
  hint="$(jq -r 'if (.enum|type) == \"array\" then \"Allowed: \" + (.enum | map(tostring) | join(\" | \")) else empty end' <<<"$rule" 2>/dev/null || true)"
  [[ "$hint" == "null" ]] && hint=""
  if [[ -n "$hint" ]]; then
    printf "%s" "$hint"
    return 0
  fi

  type="$(jq -r '.type // \"string\"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"

  case "$type" in
    bool)
      printf "%s" "Allowed: true | false"
      return 0
      ;;
    int)
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        printf "%s" "Allowed: integer $min..$max"
      elif [[ -n "$min" ]]; then
        printf "%s" "Allowed: integer >= $min"
      elif [[ -n "$max" ]]; then
        printf "%s" "Allowed: integer <= $max"
      else
        printf "%s" "Allowed: integer"
      fi
      return 0
      ;;
    number)
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        printf "%s" "Allowed: number $min..$max"
      elif [[ -n "$min" ]]; then
        printf "%s" "Allowed: number >= $min"
      elif [[ -n "$max" ]]; then
        printf "%s" "Allowed: number <= $max"
      else
        printf "%s" "Allowed: number"
      fi
      return 0
      ;;
    *)
      hint="$(jq -r '.regex // empty' <<<"$rule" 2>/dev/null || true)"
      [[ "$hint" == "null" ]] && hint=""
      if [[ -n "$hint" ]]; then
        if [[ "$hint" == "^[^\\r\\n]*$" ]]; then
          printf "%s" "Allowed: single-line string"
        else
          printf "%s" "Allowed format: $hint"
        fi
      else
        printf "%s" "String"
      fi
      return 0
      ;;
  esac
}

validation_check() {
  # Returns: 0 valid, 1 invalid, 2 unknown/unavailable.
  local var value rule required allow_empty type regex min max
  var="$1"
  value="${2-}"

  validation__clear_error
  rule="$(validation_rule_json "$var")" || return $?

  required="$(jq -r '.required // false' <<<"$rule" 2>/dev/null || echo "false")"
  [[ "$required" == "null" || -z "$required" ]] && required="false"

  allow_empty="$(jq -r '.allowEmpty // true' <<<"$rule" 2>/dev/null || echo "true")"
  [[ "$allow_empty" == "null" || -z "$allow_empty" ]] && allow_empty="true"

  if [[ -z "$value" ]]; then
    if [[ "$required" == "true" ]]; then
      validation__set_error "$var must be set"
      return 1
    fi
    if [[ "$allow_empty" == "true" ]]; then
      return 0
    fi
    validation__set_error "$var must not be empty"
    return 1
  fi

  type="$(jq -r '.type // \"string\"' <<<"$rule" 2>/dev/null || echo "string")"
  [[ "$type" == "null" || -z "$type" ]] && type="string"

  case "$type" in
    bool)
      if ! validation__is_bool "$value"; then
        validation__set_error "$var must be true or false (actual: $value)"
        return 1
      fi
      ;;
    int)
      if ! validation__is_int "$value"; then
        validation__set_error "$var must be an integer (actual: $value)"
        return 1
      fi
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && "$value" -lt "$min" ]]; then
        validation__set_error "$var must be an integer >= $min (actual: $value)"
        return 1
      fi
      if [[ -n "$max" && "$value" -gt "$max" ]]; then
        validation__set_error "$var must be an integer <= $max (actual: $value)"
        return 1
      fi
      ;;
    number)
      if ! validation__is_number "$value"; then
        validation__set_error "$var must be numeric (actual: $value)"
        return 1
      fi
      min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
      max="$(jq -r '.max // empty' <<<"$rule" 2>/dev/null || true)"
      if [[ -n "$min" && -n "$max" ]]; then
        if ! validation__number_in_range "$value" "$min" "$max"; then
          validation__set_error "$var must be between $min and $max (actual: $value)"
          return 1
        fi
      elif [[ -n "$min" ]]; then
        if ! awk -v v="$value" -v min="$min" 'BEGIN { exit !(v >= min) }'; then
          validation__set_error "$var must be >= $min (actual: $value)"
          return 1
        fi
      elif [[ -n "$max" ]]; then
        if ! awk -v v="$value" -v max="$max" 'BEGIN { exit !(v <= max) }'; then
          validation__set_error "$var must be <= $max (actual: $value)"
          return 1
        fi
      fi
      ;;
    *)
      regex="$(jq -r '.regex // empty' <<<"$rule" 2>/dev/null || true)"
      [[ "$regex" == "null" ]] && regex=""
      if [[ -n "$regex" ]] && ! [[ "$value" =~ $regex ]]; then
        validation__set_error "$var has invalid format (actual: $value)"
        return 1
      fi
      ;;
  esac

  # Enum constraint (after base type validation).
  if jq -e '(.enum|type) == "array"' <<<"$rule" >/dev/null 2>&1; then
    local allowed ok
    ok="false"
    while IFS= read -r allowed; do
      [[ "$value" == "$allowed" ]] && ok="true" && break
    done < <(jq -r '.enum[] | tostring' <<<"$rule" 2>/dev/null || true)

    if [[ "$ok" != "true" ]]; then
      allowed="$(jq -r '.enum | map(tostring) | join(\" \")' <<<"$rule" 2>/dev/null || true)"
      validation__set_error "$var must be one of: $allowed (actual: $value)"
      return 1
    fi
  fi

  # CSV/list constraint (after base type validation).
  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    local sep trim no_empty item_regex item item_trimmed
    sep="$(jq -r '.list.separator // \",\"' <<<"$rule" 2>/dev/null || echo ",")"
    trim="$(jq -r '.list.trim // false' <<<"$rule" 2>/dev/null || echo "false")"
    no_empty="$(jq -r '.list.itemNoEmpty // false' <<<"$rule" 2>/dev/null || echo "false")"
    item_regex="$(jq -r '.list.itemRegex // empty' <<<"$rule" 2>/dev/null || true)"
    [[ "$item_regex" == "null" ]] && item_regex=""

    # Only comma is supported right now (keeps behavior predictable in bash).
    if [[ "$sep" != "," ]]; then
      validation__set_error "$var: unsupported list separator in spec (separator: $sep)"
      return 2
    fi

    validation__split_csv "$value"
    for item in "${_validation_split_csv_out[@]}"; do
      item_trimmed="$item"
      if [[ "$trim" == "true" ]]; then
        item_trimmed="$(echo "$item_trimmed" | xargs)"
      fi

      if [[ "$no_empty" == "true" && -z "$item_trimmed" ]]; then
        validation__set_error "$var contains an empty item"
        return 1
      fi

      if [[ -n "$item_regex" && -n "$item_trimmed" ]] && ! [[ "$item_trimmed" =~ $item_regex ]]; then
        validation__set_error "$var contains invalid item: $item_trimmed"
        return 1
      fi
    done
  fi

  return 0
}

# --- inlined standalone support: profile/runtime logic ---
# Consolidated manager runtime library.
# Includes spec-apply, profile/env bootstrapping and validation helpers.


#
# Spec-driven helpers powered by server_manager/env/*.json.
#
# Currently used for applying ENV values into JSON config files based on a meta-field mapping
# (e.g. meta.managerJsonPath / meta.enshroudedMenuJsonPath / meta.enshroudedJsonPath).

_spec_apply_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

spec_apply__jq_set() {
  # Apply a jq transform to $file atomically (tmp+mv).
  local file tmp
  file="$1"
  shift

  tmp="$(mktemp)"
  if jq "$@" "$file" >"$tmp"; then
    mv "$tmp" "$file"
    return 0
  fi
  rm -f "$tmp" 2>/dev/null || true
  return 1
}

apply_env_to_json() {
  # Apply environment variables to a JSON file based on validation spec meta mapping.
  #
  # Usage:
  #   apply_env_to_json --file <path> --metaField <metaField> [--orderField <metaOrderField>]
  #                    [--filterPrefix <jsonPathPrefix>] [--applyEmpty true|false]
  #
  # Notes:
  # - By default, empty values are skipped (keeps existing behavior: env is for overrides, not "clear").
  # - If --applyEmpty true is used and a var is set but empty:
  #   - list env entries are set to [] (cleared)
  #   - scalar env values are set to null
  local file meta_field order_field filter_prefix apply_empty
  file=""
  meta_field=""
  order_field="menuOrder"
  filter_prefix=""
  apply_empty="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --metaField|--meta-field|--meta)
        meta_field="${2-}"
        shift 2
        ;;
      --orderField|--order-field)
        order_field="${2-}"
        shift 2
        ;;
      --filterPrefix|--filter-prefix)
        filter_prefix="${2-}"
        shift 2
        ;;
      --applyEmpty|--apply-empty)
        apply_empty="${2-true}"
        shift 2
        ;;
      *)
        echo "apply_env_to_json: unknown arg: $1" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$meta_field" ]]; then
    echo "apply_env_to_json: missing --file or --metaField" >&2
    return 1
  fi
  if [[ ! -f "$file" ]]; then
    echo "apply_env_to_json: file not found: $file" >&2
    return 1
  fi

  local any_fail var json_path rule type jq_arg value
  any_fail="false"
  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    json_path="$(validation_env_meta_field "$var" "$meta_field" 2>/dev/null || true)"
    [[ -z "$json_path" ]] && continue

    if [[ -n "$filter_prefix" ]]; then
      case "$json_path" in
        "${filter_prefix}"*) ;;
        *) continue ;;
      esac
    fi

    # Default: only apply non-empty values (preserves existing override semantics).
    if [[ "$apply_empty" == "true" ]]; then
      [[ -z "${!var+x}" ]] && continue
    else
      value="${!var-}"
      [[ -z "$value" ]] && continue
    fi

    value="${!var-}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"

    # If the value is empty but explicitly set, apply a clear behavior.
    if [[ -z "$value" ]]; then
      if [[ "$apply_empty" != "true" ]]; then
        continue
      fi
      if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
        if ! spec_apply__jq_set "$file" "$json_path = []"; then
          any_fail="true"
        fi
      else
        if ! spec_apply__jq_set "$file" "$json_path = null"; then
          any_fail="true"
        fi
      fi
      continue
    fi

    # List env values (CSV) -> JSON array.
    if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
      # Keep behavior predictable in bash: only comma separated lists are supported.
      # Spec currently only uses this for ENSHROUDED_TAGS.
      if ! spec_apply__jq_set "$file" --arg val "$value" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))"; then
        any_fail="true"
      fi
      continue
    fi

    type="$(validation_env_type "$var" 2>/dev/null || echo "string")"
    case "$type" in
      bool|int|number) jq_arg="--argjson" ;;
      *) jq_arg="--arg" ;;
    esac

    if ! spec_apply__jq_set "$file" "$jq_arg" val "$value" "$json_path = \$val"; then
      any_fail="true"
    fi
  done < <(validation_list_envs_by_meta_field_ordered "$meta_field" "$order_field")

  if [[ "$any_fail" == "true" ]]; then
    return 1
  fi
  return 0
}

spec_apply__template_default_object_json() {
  # Build a default JSON object for a template driven by env/*.json.
  #
  # - bool -> false
  # - int/number -> min (if set) else 0
  # - string -> "" (NAME defaults to "Default" for convenience)
  #
  # Usage: spec_apply__template_default_object_json <template_name> <env_prefix>
  local template env_prefix out first field var rule type min json_key value
  template="$1"
  env_prefix="$2"

  out="{"
  first="true"
  while IFS= read -r field; do
    [[ -z "$field" ]] && continue

    var="${env_prefix}_0_${field}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"
    [[ -z "$rule" ]] && continue

    type="$(jq -r '.type // "string"' <<<"$rule" 2>/dev/null || echo "string")"
    [[ "$type" == "null" || -z "$type" ]] && type="string"

    json_key="$(validation_snake_to_lower_camel "$field")"
    case "$type" in
      bool)
        value="false"
        ;;
      int|number)
        min="$(jq -r '.min // empty' <<<"$rule" 2>/dev/null || true)"
        [[ "$min" == "null" ]] && min=""
        if [[ -n "$min" ]]; then
          value="$min"
        else
          value="0"
        fi
        ;;
      *)
        if [[ "$field" == "NAME" ]]; then
          value="\"Default\""
        else
          value="\"\""
        fi
        ;;
    esac

    if [[ "$first" == "true" ]]; then
      first="false"
    else
      out="${out},"
    fi
    out="${out}\"${json_key}\":${value}"
  done < <(validation_list_template_fields "$template")
  out="${out}}"

  printf "%s" "$out"
}

apply_env_template_to_json_array() {
  # Apply template-driven environment variables to a JSON array of objects.
  #
  # ENV schema:
  #   <ENV_PREFIX>_<index>_<FIELD>
  #
  # The template fields/rules come from:
  #   .templates[template].fields[FIELD]
  #
  # Usage:
  #   apply_env_template_to_json_array --file <path> --template <template> --envPrefix <ENV_PREFIX> --arrayPath <jq_path>
  #                                   [--applyEmpty true|false]
  #
  # Notes:
  # - By default, empty values are skipped (env is for overrides, not "clear").
  # - If --applyEmpty true is used and a var is set but empty:
  #   - list env entries are set to [] (cleared)
  #   - scalar env values are set to null
  local file template env_prefix array_path apply_empty
  file=""
  template=""
  env_prefix=""
  array_path=""
  apply_empty="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --template)
        template="${2-}"
        shift 2
        ;;
      --envPrefix|--env-prefix)
        env_prefix="${2-}"
        shift 2
        ;;
      --arrayPath|--array-path)
        array_path="${2-}"
        shift 2
        ;;
      --applyEmpty|--apply-empty)
        apply_empty="${2-true}"
        shift 2
        ;;
      *)
        echo "apply_env_template_to_json_array: unknown arg: $1" >&2
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$template" || -z "$env_prefix" || -z "$array_path" ]]; then
    echo "apply_env_template_to_json_array: missing --file/--template/--envPrefix/--arrayPath" >&2
    return 1
  fi
  if [[ ! -f "$file" ]]; then
    echo "apply_env_template_to_json_array: file not found: $file" >&2
    return 1
  fi

  # Ensure the array exists (and is an array).
  if ! jq -e "$array_path | type == \"array\"" "$file" >/dev/null 2>&1; then
    if ! spec_apply__jq_set "$file" "$array_path = []"; then
      return 1
    fi
  fi

  # Find highest index referenced by any template env var (prefix match).
  local max_idx var idx
  max_idx="-1"
  for var in $(compgen -A variable "${env_prefix}_"); do
    if [[ "$var" =~ ^${env_prefix}_([0-9]+)_.+ ]]; then
      idx="${BASH_REMATCH[1]}"
      if [[ "$idx" =~ ^[0-9]+$ ]] && ((idx > max_idx)); then
        max_idx="$idx"
      fi
    fi
  done

  # Ensure array entries exist up to max_idx by appending a default object derived from the template.
  if ((max_idx >= 0)); then
    local default_obj i
    default_obj="$(spec_apply__template_default_object_json "$template" "$env_prefix")"
    for i in $(seq 0 "$max_idx"); do
      if ! jq -e --argjson idx "$i" "$array_path | has($idx)" "$file" >/dev/null 2>&1; then
        spec_apply__jq_set "$file" --argjson obj "$default_obj" "$array_path += [\$obj]" || true
      fi
    done
  fi

  local any_fail value field json_key json_path rule type jq_arg
  any_fail="false"

  for var in $(compgen -A variable "${env_prefix}_"); do
    if [[ ! "$var" =~ ^${env_prefix}_([0-9]+)_(.+)$ ]]; then
      continue
    fi
    idx="${BASH_REMATCH[1]}"
    field="${BASH_REMATCH[2]}"

    # Default: only apply non-empty values (preserves existing override semantics).
    if [[ "$apply_empty" == "true" ]]; then
      [[ -z "${!var+x}" ]] && continue
    else
      value="${!var-}"
      [[ -z "$value" ]] && continue
    fi

    value="${!var-}"

    # Skip unknown fields (also avoids accidental JSON injection from env var names).
    if ! validation_rule_json "$var" >/dev/null 2>&1; then
      continue
    fi

    json_key="$(validation_snake_to_lower_camel "$field")"
    json_path="${array_path}[\$idx].${json_key}"
    rule="$(validation_rule_json "$var" 2>/dev/null || true)"

    # If the value is empty but explicitly set, apply a clear behavior.
    if [[ -z "$value" ]]; then
      if [[ "$apply_empty" != "true" ]]; then
        continue
      fi
      if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
        if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$json_path = []"; then
          any_fail="true"
        fi
      else
        if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$json_path = null"; then
          any_fail="true"
        fi
      fi
      continue
    fi

    # List env values (CSV) -> JSON array.
    if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
      if ! spec_apply__jq_set "$file" --argjson idx "$idx" --arg val "$value" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))"; then
        any_fail="true"
      fi
      continue
    fi

    type="$(validation_env_type "$var" 2>/dev/null || echo "string")"
    case "$type" in
      bool|int|number) jq_arg="--argjson" ;;
      *) jq_arg="--arg" ;;
    esac

    if ! spec_apply__jq_set "$file" --argjson idx "$idx" "$jq_arg" val "$value" "$json_path = \$val"; then
      any_fail="true"
    fi
  done

  if [[ "$any_fail" == "true" ]]; then
    return 1
  fi
  return 0
}


EN_PROFILE="${EN_PROFILE:-}"
MANAGER_PROFILE="${MANAGER_PROFILE:-}"

EN_PROFILE_DEFAULT="default"
MANAGER_PROFILE_DEFAULT="default"

PROFILE_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MANAGER_ROOT="${MANAGER_ROOT:-$(cd "$PROFILE_SCRIPT_DIR/.." && pwd)}"


MANAGER_DATA_DIR="${MANAGER_DATA_DIR:-${install_path}/server_manager}"
MANAGER_PROFILE_ROOT="${MANAGER_PROFILE_ROOT:-${install_path}/profile}"
MANAGER_PROFILE_DIR="$MANAGER_PROFILE_ROOT"

# Server Manager profile templates:
# - MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR: templates shipped with the image (read-only layer)
# - MANAGER_PROFILE_TEMPLATE_DIR: runtime profile catalog used by menu/apply/reset (default: persistent volume)
MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR="${MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR:-${MANAGER_ROOT}/profiles/manager}"
MANAGER_PROFILE_TEMPLATE_DIR="${MANAGER_PROFILE_TEMPLATE_DIR:-${install_path}/profiles/manager}"

# Enshrouded profile templates:
# - EN_PROFILE_TEMPLATE_DIR: templates shipped with the image (read-only layer)
# - EN_PROFILE_DIR: runtime profile catalog used by menu/apply/reset (default: persistent volume)
EN_PROFILE_TEMPLATE_DIR="${EN_PROFILE_TEMPLATE_DIR:-${MANAGER_ROOT}/profiles/enshrouded}"
EN_PROFILE_DIR="${EN_PROFILE_DIR:-${install_path}/profiles/enshrouded}"

# Profile catalog listing helpers (used by the interactive menu).
profiles_list_enshrouded() {
  local f name
  shopt -s nullglob
  for f in "$EN_PROFILE_DIR"/*_enshrouded_server.json; do
    name="$(basename "$f")"
    name="${name%_enshrouded_server.json}"
    echo "$name"
  done
  shopt -u nullglob
}

profiles_list_manager() {
  local f name
  shopt -s nullglob
  for f in "$MANAGER_PROFILE_TEMPLATE_DIR"/*_server_manager.json; do
    name="$(basename "$f")"
    name="${name%_server_manager.json}"
    echo "$name"
  done
  shopt -u nullglob
}

# Profile selection persistence (single source of truth):
# Stored in server_manager.json as top-level keys:
#   actualProfilManager       (selected Server Manager profile name)
#   actualProfilEnshrouded    (selected Enshrouded profile name)
#
# Additionally, the initial ENV selectors are captured once for transparency:
#   MANAGER_PROFILE
#   EN_PROFILE

profiles_config_json_key() {
  # Map internal selector names to JSON keys.
  # Usage: profiles_config_json_key manager|enshrouded
  case "$1" in
    manager) echo "actualProfilManager" ;;
    enshrouded) echo "actualProfilEnshrouded" ;;
    *) echo "" ;;
  esac
}

profiles_ensure_schema() {
  # Ensure the 4 profile selection keys exist (always strings, never null).
  local file tmp mdef edef
  file="$(manager_config_path)"
  mdef="$MANAGER_PROFILE_DEFAULT"
  edef="$EN_PROFILE_DEFAULT"

  if ! command -v jq >/dev/null 2>&1; then
    return 0
  fi
  if [[ ! -f "$file" ]] || ! jq -e 'type == "object"' "$file" >/dev/null 2>&1; then
    return 0
  fi

  tmp="$(mktemp)"
  jq --arg mdef "$mdef" --arg edef "$edef" '
    .MANAGER_PROFILE = (if (.MANAGER_PROFILE == null or .MANAGER_PROFILE == "") then $mdef else .MANAGER_PROFILE end)
    | .EN_PROFILE = (if (.EN_PROFILE == null or .EN_PROFILE == "") then $edef else .EN_PROFILE end)
    | .actualProfilManager = (if (.actualProfilManager == null or .actualProfilManager == "") then $mdef else .actualProfilManager end)
    | .actualProfilEnshrouded = (if (.actualProfilEnshrouded == null or .actualProfilEnshrouded == "") then $edef else .actualProfilEnshrouded end)
    | del(.profiles)
  ' "$file" >"$tmp" || {
    rm -f "$tmp"
    return 0
  }
  mv "$tmp" "$file"
  chmod 600 "$file" 2>/dev/null || true
  chown enshrouded:enshrouded "$file" 2>/dev/null || true
  return 0
}

profiles_config_get() {
  # Get a profile selector value from server_manager.json (top-level keys).
  # Usage: profiles_config_get manager|enshrouded
  local key json_key file value
  key="$1"
  json_key="$(profiles_config_json_key "$key")"
  if [[ -z "$json_key" ]]; then
    echo ""
    return 0
  fi
  file="$(manager_config_path)"
  if ! command -v jq >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  if [[ ! -f "$file" ]] || ! jq -e 'type == "object"' "$file" >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  value="$(jq -r --arg key "$json_key" '.[$key] // empty' "$file" 2>/dev/null || true)"
  if [[ "$value" == "null" ]]; then
    value=""
  fi

  echo "$value"
}

profiles_env_get() {
  # Get a captured ENV selector value from server_manager.json (top-level keys).
  # Usage: profiles_env_get EN_PROFILE|MANAGER_PROFILE
  local key file value
  key="$1"
  file="$(manager_config_path)"
  if ! command -v jq >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  if [[ ! -f "$file" ]] || ! jq -e 'type == "object"' "$file" >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  value="$(jq -r --arg key "$key" '.[$key] // empty' "$file" 2>/dev/null || true)"
  if [[ "$value" == "null" ]]; then
    value=""
  fi

  echo "$value"
}

profiles_config_set() {
  # Set a profile selector value in server_manager.json (top-level keys).
  # Usage: profiles_config_set manager|enshrouded <value>
  local key json_key value file tmp def
  key="$1"
  value="${2-}"
  json_key="$(profiles_config_json_key "$key")"
  if [[ -z "$json_key" ]]; then
    return 0
  fi
  file="$(manager_config_path)"
  case "$key" in
    enshrouded) def="$EN_PROFILE_DEFAULT" ;;
    *) def="$MANAGER_PROFILE_DEFAULT" ;;
  esac

  if ! command -v jq >/dev/null 2>&1; then
    warn "jq not found: cannot persist profile selection"
    return 1
  fi
  if [[ ! -f "$file" ]] || ! jq -e 'type == "object"' "$file" >/dev/null 2>&1; then
    warn "server_manager.json missing/invalid: cannot persist profile selection"
    return 1
  fi

  tmp="$(mktemp)"
  if [[ -z "$value" ]]; then
    value="$def"
  fi

  jq --arg key "$json_key" --arg value "$value" '.[$key] = $value | del(.profiles)' "$file" >"$tmp" || {
    rm -f "$tmp"
    return 1
  }

  mv "$tmp" "$file"
  chmod 600 "$file" 2>/dev/null || true
  chown enshrouded:enshrouded "$file" 2>/dev/null || true
  return 0
}

profiles_env_set_if_missing() {
  # Capture ENV selector values once (do not overwrite a non-empty existing value).
  #
  # If the key exists but is "default"/null/empty (e.g., seeded by a template),
  # this will set it if the provided value is non-empty.
  # Usage: profiles_env_set_if_missing EN_PROFILE|MANAGER_PROFILE <value>
  local key value file tmp current def
  key="$1"
  value="${2-}"
  case "$key" in
    EN_PROFILE) def="$EN_PROFILE_DEFAULT" ;;
    *) def="$MANAGER_PROFILE_DEFAULT" ;;
  esac

  current="$(profiles_env_get "$key")"
  if [[ -n "$current" && "$current" != "$def" ]]; then
    return 0
  fi
  if [[ -z "$value" ]]; then
    return 0
  fi

  file="$(manager_config_path)"
  if ! command -v jq >/dev/null 2>&1; then
    return 0
  fi
  if [[ ! -f "$file" ]] || ! jq -e 'type == "object"' "$file" >/dev/null 2>&1; then
    return 0
  fi

  tmp="$(mktemp)"
  jq --arg key "$key" --arg value "$value" '.[$key] = $value | del(.profiles)' "$file" >"$tmp" || {
    rm -f "$tmp"
    return 0
  }
  mv "$tmp" "$file"
  chmod 600 "$file" 2>/dev/null || true
  chown enshrouded:enshrouded "$file" 2>/dev/null || true
  return 0
}

manager_config_path() {
  printf "%s/server_manager.json" "$MANAGER_DATA_DIR"
}

backup_dir_resolve() {
  # Resolve BACKUP_DIR to an absolute path (same behavior as unified backup job).
  local dir
  dir="${BACKUP_DIR:-backups}"
  if [[ "$dir" == /* ]]; then
    printf "%s" "$dir"
  else
    printf "%s/%s" "$install_path" "$dir"
  fi
}

manual_backups_dir() {
  # Store manual backups under BACKUP_DIR/manual.
  printf "%s/manual" "$(backup_dir_resolve)"
}

backup_config_file() {
  # Create a timestamped config-only ZIP backup under BACKUP_DIR/manual.
  # Usage: backup_config_file <src_file> <label>
  local src label backup_root ts dest n tmp_dir config_name
  src="$1"
  label="$2"

  if [[ -z "$src" || -z "$label" ]]; then
    warn "backup_config_file: missing arguments"
    return 1
  fi

  if [[ ! -f "$src" ]]; then
    return 0
  fi

  backup_root="$(manual_backups_dir)"
  mkdir -p "$backup_root" 2>/dev/null || true
  chmod 700 "$backup_root" 2>/dev/null || true
  chown enshrouded:enshrouded "$backup_root" 2>/dev/null || true

  ts="$(date +%Y-%m-%d_%H-%M-%S)"
  dest="${backup_root}/${ts}-manual-config-${label}.zip"
  if [[ -e "$dest" ]]; then
    n=1
    while [[ -e "${backup_root}/${ts}-manual-config-${label}-${n}.zip" ]]; do
      n=$((n + 1))
    done
    dest="${backup_root}/${ts}-manual-config-${label}-${n}.zip"
  fi

  case "$label" in
    enshrouded_server) config_name="enshrouded_server.json" ;;
    server_manager) config_name="server_manager.json" ;;
    *) config_name="${label}.json" ;;
  esac

  tmp_dir="$(mktemp -d)"
  mkdir -p "${tmp_dir}/config" 2>/dev/null || true

  if cp "$src" "${tmp_dir}/config/${config_name}" 2>/dev/null \
    && jq -n \
      --arg createdAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
      --arg label "$label" \
      '{
        version: 1,
        mode: "manual",
        createdAt: $createdAt,
        includes: {
          savegame: false,
          enshroudedConfig: ($label == "enshrouded_server"),
          serverManagerConfig: ($label == "server_manager")
        }
      }' >"${tmp_dir}/manifest.json" \
    && (cd "$tmp_dir" && zip -qr "$dest" .); then
    rm -rf "$tmp_dir" 2>/dev/null || true
    chmod 600 "$dest" 2>/dev/null || true
    chown enshrouded:enshrouded "$dest" 2>/dev/null || true
    if declare -F ui_success >/dev/null 2>&1; then
      ui_success "Backup created: $dest"
    elif declare -F info >/dev/null 2>&1; then
      info "Backup created: $dest"
    fi
    return 0
  fi

  rm -rf "$tmp_dir" 2>/dev/null || true
  warn "Failed to create backup: $dest"
  return 1
}

manager_profile_path() {
  local name
  name="${1:-$MANAGER_PROFILE_DEFAULT}"
  printf "%s/%s/%s_server_manager.json" "$MANAGER_PROFILE_DIR" "$name" "$name"
}

manager_profile_template_path() {
  local name
  name="${1:-$MANAGER_PROFILE_DEFAULT}"
  printf "%s/%s_server_manager.json" "$MANAGER_PROFILE_TEMPLATE_DIR" "$name"
}

manager_profile_template_shipped_path() {
  local name
  name="${1:-$MANAGER_PROFILE_DEFAULT}"
  printf "%s/%s_server_manager.json" "$MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR" "$name"
}

enshrouded_profile_path() {
  local name
  name="${1:-$EN_PROFILE_DEFAULT}"
  printf "%s/%s_enshrouded_server.json" "$EN_PROFILE_DIR" "$name"
}

enshrouded_profile_template_path() {
  local name
  name="${1:-$EN_PROFILE_DEFAULT}"
  printf "%s/%s_enshrouded_server.json" "$EN_PROFILE_TEMPLATE_DIR" "$name"
}

manager_profile_resolve() {
  local name
  name="$(profiles_config_get "manager")"
  if [[ -z "$name" ]]; then
    # Only used when server_manager.json does not have a persisted selector (bootstrap/new volume).
    name="${MANAGER_PROFILE:-}"
  fi
  if [[ -n "$name" ]]; then
    if validation_check "MANAGER_PROFILE" "$name"; then
      :
    else
      local rc
      rc=$?
      if [[ "$rc" -eq 1 ]]; then
        warn "Invalid manager profile selector: $name (fallback: $MANAGER_PROFILE_DEFAULT)"
        name=""
      fi
    fi
  fi
  if [[ -z "$name" ]]; then
    echo "$MANAGER_PROFILE_DEFAULT"
    return 0
  fi
  if [[ -f "$(manager_profile_path "$name")" || -f "$(manager_profile_template_path "$name")" || -f "$(manager_profile_template_shipped_path "$name")" ]]; then
    echo "$name"
    return 0
  fi
  warn "Profile not found: $name (fallback: $MANAGER_PROFILE_DEFAULT)"
  echo "$MANAGER_PROFILE_DEFAULT"
}

enshrouded_profile_resolve() {
  local name
  name="$(profiles_config_get "enshrouded")"
  if [[ -z "$name" ]]; then
    # Only used when server_manager.json does not have a persisted selector (bootstrap/new volume).
    name="${EN_PROFILE:-}"
  fi
  if [[ -n "$name" ]]; then
    if validation_check "EN_PROFILE" "$name"; then
      :
    else
      local rc
      rc=$?
      if [[ "$rc" -eq 1 ]]; then
        warn "Invalid enshrouded profile selector: $name (fallback: $EN_PROFILE_DEFAULT)"
        name=""
      fi
    fi
  fi
  if [[ -z "$name" ]]; then
    echo "$EN_PROFILE_DEFAULT"
    return 0
  fi
  if [[ -f "$(enshrouded_profile_path "$name")" || -f "$(enshrouded_profile_template_path "$name")" ]]; then
    echo "$name"
    return 0
  fi
  warn "Enshrouded profile not found: $name (fallback: $EN_PROFILE_DEFAULT)"
  echo "$EN_PROFILE_DEFAULT"
}

enshrouded_profile_resolve_from_value() {
  # Resolve an Enshrouded profile name without reading persisted selectors.
  # Usage: enshrouded_profile_resolve_from_value <name>
  local name
  name="${1-}"
  if [[ -n "$name" ]]; then
    if validation_check "EN_PROFILE" "$name"; then
      :
    else
      local rc
      rc=$?
      if [[ "$rc" -eq 1 ]]; then
        warn "Invalid enshrouded profile selector: $name (fallback: $EN_PROFILE_DEFAULT)"
        name=""
      fi
    fi
  fi
  if [[ -z "$name" ]]; then
    echo "$EN_PROFILE_DEFAULT"
    return 0
  fi
  if [[ -f "$(enshrouded_profile_path "$name")" || -f "$(enshrouded_profile_template_path "$name")" ]]; then
    echo "$name"
    return 0
  fi
  warn "Enshrouded profile not found: $name (fallback: $EN_PROFILE_DEFAULT)"
  echo "$EN_PROFILE_DEFAULT"
}

ensure_manager_paths() {
  mkdir -p "$MANAGER_DATA_DIR" "$MANAGER_PROFILE_ROOT"
}

ensure_manager_profile_file() {
  local profile profile_file template_file
  profile="$1"
  profile_file="$(manager_profile_path "$profile")"
  template_file="$(manager_profile_template_path "$profile")"

  if [[ -f "$profile_file" ]]; then
    return 0
  fi
  if [[ ! -f "$template_file" ]]; then
    # If the persistent template catalog is empty (fresh volume), fall back to shipped templates.
    local shipped
    shipped="$(manager_profile_template_shipped_path "$profile")"
    if [[ -f "$shipped" ]]; then
      mkdir -p "$(dirname "$template_file")" 2>/dev/null || true
      if cp "$shipped" "$template_file" 2>/dev/null; then
        chmod 600 "$template_file" 2>/dev/null || true
        chown enshrouded:enshrouded "$template_file" 2>/dev/null || true
      fi
    fi
  fi
  if [[ ! -f "$template_file" ]]; then
    warn "Server Manager profile template not found: $template_file"
    return 1
  fi
  if ! jq -e '.' "$template_file" >/dev/null 2>&1; then
    warn "Invalid JSON in server manager profile template: $template_file"
    return 1
  fi

  mkdir -p "$(dirname "$profile_file")" 2>/dev/null || true
  cp "$template_file" "$profile_file"
  info "Server Manager profile created: $profile_file"
}

ensure_manager_profile_catalog() {
  # Seed MANAGER_PROFILE_TEMPLATE_DIR with shipped templates (copy only missing files).
  local src_dir dest_dir f dest
  src_dir="${MANAGER_PROFILE_TEMPLATE_SHIPPED_DIR:-}"
  dest_dir="${MANAGER_PROFILE_TEMPLATE_DIR:-}"

  if [[ -z "$src_dir" || -z "$dest_dir" ]]; then
    return 0
  fi
  if [[ "$src_dir" == "$dest_dir" ]]; then
    return 0
  fi

  mkdir -p "$dest_dir" 2>/dev/null || true

  shopt -s nullglob
  for f in "$src_dir"/*_server_manager.json; do
    dest="$dest_dir/$(basename "$f")"
    if [[ -e "$dest" ]]; then
      continue
    fi
    if ! jq -e '.' "$f" >/dev/null 2>&1; then
      warn "Invalid JSON in server manager profile template: $f (skipping)"
      continue
    fi
    if cp "$f" "$dest" 2>/dev/null; then
      chmod 600 "$dest" 2>/dev/null || true
      chown enshrouded:enshrouded "$dest" 2>/dev/null || true
    else
      warn "Failed to seed Server Manager profile template: $dest"
    fi
  done
  shopt -u nullglob
}

ensure_enshrouded_profile_file() {
  local profile profile_file template_file
  profile="$1"
  profile_file="$(enshrouded_profile_path "$profile")"
  template_file="$(enshrouded_profile_template_path "$profile")"

  if [[ -f "$profile_file" ]]; then
    return 0
  fi
  if [[ ! -f "$template_file" ]]; then
    warn "Enshrouded profile template not found: $template_file"
    return 1
  fi
  if ! jq -e '.' "$template_file" >/dev/null 2>&1; then
    warn "Invalid JSON in enshrouded profile template: $template_file"
    return 1
  fi

  mkdir -p "$(dirname "$profile_file")" 2>/dev/null || true
  if cp "$template_file" "$profile_file" 2>/dev/null; then
    chmod 600 "$profile_file" 2>/dev/null || true
    chown enshrouded:enshrouded "$profile_file" 2>/dev/null || true
    info "Enshrouded profile created: $profile_file"
    return 0
  fi

  warn "Failed to create Enshrouded profile: $profile_file"
  return 1
}

ensure_enshrouded_profile_catalog() {
  # Seed EN_PROFILE_DIR with shipped templates (copy only missing files).
  local src_dir dest_dir f dest
  src_dir="${EN_PROFILE_TEMPLATE_DIR:-}"
  dest_dir="${EN_PROFILE_DIR:-}"

  if [[ -z "$src_dir" || -z "$dest_dir" ]]; then
    return 0
  fi
  if [[ "$src_dir" == "$dest_dir" ]]; then
    return 0
  fi

  mkdir -p "$dest_dir" 2>/dev/null || true

  shopt -s nullglob
  for f in "$src_dir"/*_enshrouded_server.json; do
    dest="$dest_dir/$(basename "$f")"
    if [[ -e "$dest" ]]; then
      continue
    fi
    if ! jq -e '.' "$f" >/dev/null 2>&1; then
      warn "Invalid JSON in enshrouded profile template: $f (skipping)"
      continue
    fi
    if cp "$f" "$dest" 2>/dev/null; then
      chmod 600 "$dest" 2>/dev/null || true
      chown enshrouded:enshrouded "$dest" 2>/dev/null || true
    else
      warn "Failed to seed Enshrouded profile template: $dest"
    fi
  done
  shopt -u nullglob
}

manager_json_get() {
  local file var path
  file="$1"
  var="$2"
  path="$(validation_env_meta_field "$var" "managerJsonPath" 2>/dev/null || true)"
  if [[ -z "$path" || ! -f "$file" ]]; then
    echo ""
    return 0
  fi
  # Keep `false` visible (jq's `// empty` treats false as empty).
  jq -r "$path | if . == null then empty else tostring end" "$file" 2>/dev/null || true
}

manager_value_is_valid() {
  local var value rc
  var="$1"
  value="$2"

  if validation_check "$var" "$value"; then
    return 0
  fi
  rc=$?
  case "$rc" in
    0) return 0 ;;
    1) return 1 ;;
    *) return 0 ;; # Unknown rule/unavailable validator: do not block bootstrap.
  esac
}

manager_config_set() {
  local file temp_file
  file="$1"
  shift
  temp_file="$(mktemp)"
  if jq "$@" "$file" >"$temp_file"; then
    mv "$temp_file" "$file"
    chmod 600 "$file" 2>/dev/null || true
    chown enshrouded:enshrouded "$file" 2>/dev/null || true
  else
    rm -f "$temp_file"
    warn "Failed to update $file (jq error)"
  fi
}

manager_config_set_value() {
  local file var value path type
  file="$1"
  var="$2"
  value="${3-}"
  path="$(validation_env_meta_field "$var" "managerJsonPath" 2>/dev/null || true)"
  type="$(validation_env_type "$var" 2>/dev/null || true)"
  [[ -z "$type" ]] && type="string"
  if [[ -z "$path" ]]; then
    return 0
  fi
  if [[ -z "$value" ]]; then
    manager_config_set "$file" "$path = null"
    return 0
  fi
  case "$type" in
    bool|int|number)
      manager_config_set "$file" --argjson val "$value" "$path = \$val"
      ;;
    *)
      manager_config_set "$file" --arg val "$value" "$path = \$val"
      ;;
  esac
}

profiles_env_set_if_empty_validated() {
  # Set an env var only if it is currently empty/unset and the candidate is valid.
  # Usage: profiles_env_set_if_empty_validated <VAR_NAME> <candidate_value> <source_label>
  local var candidate source rc
  var="$1"
  candidate="${2-}"
  source="${3-}"

  if [[ -n "${!var-}" ]]; then
    return 0
  fi
  if [[ -z "$candidate" ]]; then
    return 0
  fi

  if validation_check "$var" "$candidate"; then
    printf -v "$var" '%s' "$candidate"
    return 0
  fi

  rc=$?
  case "$rc" in
    1)
      warn "Invalid $var in $source (actual: $candidate)"
      return 1
      ;;
    *)
      # Unknown rule/unavailable validator: accept candidate (keeps older behavior).
      printf -v "$var" '%s' "$candidate"
      return 0
      ;;
  esac
}

manager_profile_value_for_var() {
  local profile var file value
  profile="$1"
  var="$2"
  file="$(manager_profile_path "$profile")"
  value="$(manager_json_get "$file" "$var")"
  echo "$value"
}

update_or_create_manager_config() {
  local config_file profile value env_value var created_config
  created_config="false"

  if ! command -v jq >/dev/null 2>&1; then
    warn "jq not found: skipping server_manager.json initialization"
    return 0
  fi

  ensure_manager_paths
  profile="$(manager_profile_resolve)"

  if ! ensure_manager_profile_file "$MANAGER_PROFILE_DEFAULT"; then
    return 1
  fi
  if ! ensure_manager_profile_file "$profile"; then
    return 1
  fi

  config_file="$(manager_config_path)"
  if [[ ! -f "$config_file" ]] || ! jq -e 'type == "object"' "$config_file" >/dev/null 2>&1; then
    cp "$(manager_profile_path "$profile")" "$config_file"
    info "server_manager.json initialized from profile: $profile"
    created_config="true"
  fi

  # Ensure profile selection keys exist (and drop legacy .profiles if present).
  profiles_ensure_schema || true

  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    env_value="$(printenv "$var" 2>/dev/null || true)"
    value=""

    # ENV override (docker-compose/container environment) wins, but should never poison config.
    if [[ -n "$env_value" ]]; then
      if manager_value_is_valid "$var" "$env_value"; then
        value="$env_value"
      else
        warn "Invalid ENV value for $var (actual: $env_value) - ignoring"
      fi
    fi

    # Fallback: active config -> profile template.
    if [[ -z "$value" ]]; then
      value="$(manager_json_get "$config_file" "$var")"
      if [[ -n "$value" ]] && ! manager_value_is_valid "$var" "$value"; then
        warn "Invalid server_manager.json value for $var (actual: $value) - resetting to profile/default"
        value=""
      fi
      if [[ -z "$value" ]]; then
        value="$(manager_profile_value_for_var "$profile" "$var")"
        if [[ -n "$value" ]] && ! manager_value_is_valid "$var" "$value"; then
          warn "Invalid manager profile value for $var (profile: $profile, actual: $value)"
          value=""
        fi
      fi
    fi

    printf -v "$var" '%s' "$value"
    if [[ -n "$value" ]]; then
      export "$var"
    fi
    manager_config_set_value "$config_file" "$var" "$value"
  done < <(validation_list_envs_by_meta_field "managerJsonPath")

  # Persist profile selection in server_manager.json (single source of truth).
  profiles_env_set_if_missing "MANAGER_PROFILE" "${MANAGER_PROFILE:-}" || true
  profiles_env_set_if_missing "EN_PROFILE" "${EN_PROFILE:-}" || true

  # Keep persisted selectors in sync with resolved profiles.
  profiles_config_set "manager" "$profile" || true
  if [[ "$created_config" == "true" ]]; then
    # On first init, allow EN_PROFILE to seed the persisted Enshrouded profile selection.
    profiles_config_set "enshrouded" "$(enshrouded_profile_resolve_from_value "${EN_PROFILE:-}")" || true
  else
    profiles_config_set "enshrouded" "$(enshrouded_profile_resolve)" || true
  fi
}

load_enshrouded_env_from_profile() {
  local profile profile_file config_file
  config_file="${install_path}/enshrouded_server.json"

  # Prefer existing runtime config as the source of truth for runtime defaults.
  # This keeps manual edits (e.g. via ctl menu) consistent across restarts.
  if command -v jq >/dev/null 2>&1 && [[ -f "$config_file" ]] && jq -e '.' "$config_file" >/dev/null 2>&1; then
    local var path candidate
    while IFS= read -r var; do
      [[ -z "$var" ]] && continue
      [[ -n "${!var-}" ]] && continue
      path="$(validation_env_meta_field "$var" "enshroudedJsonPath" 2>/dev/null || true)"
      [[ -z "$path" ]] && continue
      candidate="$(jq -r "$path | if . == null then empty else tostring end" "$config_file" 2>/dev/null || true)"
      profiles_env_set_if_empty_validated "$var" "$candidate" "$config_file" || true
    done < <(validation_list_envs_by_meta_field "enshroudedJsonPath")
  fi

  profile="$(enshrouded_profile_resolve)"
  # Prefer a persisted profile file in EN_PROFILE_DIR, seed from shipped templates if needed.
  ensure_enshrouded_profile_file "$profile" || true
  profile_file="$(enshrouded_profile_path "$profile")"
  if [[ ! -f "$profile_file" ]]; then
    profile_file="$(enshrouded_profile_template_path "$profile")"
  fi

  if [[ ! -f "$profile_file" ]]; then
    return 1
  fi
  if ! jq -e '.' "$profile_file" >/dev/null 2>&1; then
    return 1
  fi

  local var path candidate
  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    [[ -n "${!var-}" ]] && continue
    path="$(validation_env_meta_field "$var" "enshroudedJsonPath" 2>/dev/null || true)"
    [[ -z "$path" ]] && continue
    candidate="$(jq -r "$path | if . == null then empty else tostring end" "$profile_file" 2>/dev/null || true)"
    profiles_env_set_if_empty_validated "$var" "$candidate" "$profile_file" || true
  done < <(validation_list_envs_by_meta_field "enshroudedJsonPath")

  return 0
}

init_runtime_env() {
  # Ensure MANAGER_PROFILE_TEMPLATE_DIR contains a persistent copy of shipped Server Manager templates.
  ensure_manager_profile_catalog || true

  if ! update_or_create_manager_config; then
    fatal "Failed to initialize server_manager.json from profile"
  fi

  # Ensure EN_PROFILE_DIR contains a persistent copy of shipped Enshrouded templates.
  ensure_enshrouded_profile_catalog || true

  if ! load_enshrouded_env_from_profile; then
    fatal "Failed to load Enshrouded profile defaults"
  fi

  savefile_name="$SAVEFILE_NAME"
  steam_app_id="$STEAM_APP_ID"
}

ensure_enshrouded_config_from_profile() {
  local profile source_profile config_file temp_file

  config_file="${install_path}/enshrouded_server.json"
  if [[ -f "$config_file" ]]; then
    return 0
  fi

  profile="$(enshrouded_profile_resolve)"
  source_profile="$(enshrouded_profile_path "$profile")"
  if [[ ! -f "$source_profile" ]]; then
    # If EN_PROFILE_DIR is empty (fresh volume), fall back to shipped templates.
    ensure_enshrouded_profile_file "$profile" || true
    source_profile="$(enshrouded_profile_path "$profile")"
  fi
  if [[ ! -f "$source_profile" ]]; then
    source_profile="$(enshrouded_profile_template_path "$profile")"
  fi
  if [[ ! -f "$source_profile" ]]; then
    warn "No enshrouded profile file found for '$profile' (searched: $EN_PROFILE_DIR, $EN_PROFILE_TEMPLATE_DIR)"
    return 1
  fi
  if ! jq -e '.' "$source_profile" >/dev/null 2>&1; then
    warn "Invalid JSON in enshrouded profile: $source_profile"
    return 1
  fi

  mkdir -p "$install_path"
  temp_file="$(mktemp)"
  if jq 'if has("bans") then . else . + {bans: []} end' "$source_profile" >"$temp_file"; then
    mv "$temp_file" "$config_file"
    chmod 600 "$config_file" 2>/dev/null || true
    chown enshrouded:enshrouded "$config_file" 2>/dev/null || true
    info "Created enshrouded_server.json from profile: $profile"
    return 0
  fi

  rm -f "$temp_file"
  warn "Failed to create enshrouded_server.json from profile: $profile"
  return 1
}


ENV_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

validate_template_env_values() {
  # Validate any template-driven env values declared in env/*.json (.templates).
  local template var_name value
  while IFS= read -r template; do
    [[ -z "$template" ]] && continue
    for var_name in $(compgen -A variable "${template}_" || true); do
      [[ "$var_name" =~ ^${template}_[0-9]+_ ]] || continue
      value="${!var_name-}"
      env_validate_var_from_spec "$var_name" "$value" || true
    done
  done < <(validation_list_templates)
}

validate_known_env_from_spec() {
  local var_name value
  while IFS= read -r var_name; do
    [[ -z "$var_name" ]] && continue
    value="${!var_name-}"
    env_validate_var_from_spec "$var_name" "$value" || true
  done < <(validation_list_envs)
}

validate_unknown_game_settings_env_values() {
  local var_name
  if ! validation__has_spec_files || ! command -v jq >/dev/null 2>&1; then
    return 0
  fi
  for var_name in $(compgen -A variable | grep '^ENSHROUDED_GS_' || true); do
    if ! validation_rule_json "$var_name" >/dev/null 2>&1; then
      warn "Unknown game setting env var detected: $var_name"
    fi
  done
}

env_validate_var() {
  # Usage: env_validate_var <var_name> <value> hard|soft
  local var value mode rc
  var="$1"
  value="${2-}"
  mode="$3"

  if validation_check "$var" "$value"; then
    return 0
  fi
  rc=$?
  case "$rc" in
    1)
      if [[ "$mode" == "hard" ]]; then
        fatal "$VALIDATION_LAST_ERROR"
      fi
      warn "$VALIDATION_LAST_ERROR"
      return 1
      ;;
    *)
      # Unknown rule / unavailable validator: warn but do not block bootstrap.
      warn "$VALIDATION_LAST_ERROR"
      return 0
      ;;
  esac
}

env_validate_var_from_spec() {
  # Usage: env_validate_var_from_spec <var_name> <value>
  local var value mode required
  var="$1"
  value="${2-}"
  mode="$(validation_env_mode "$var" 2>/dev/null || true)"
  if [[ "$mode" != "hard" && "$mode" != "soft" ]]; then
    required="$(validation_env_required "$var" 2>/dev/null || true)"
    if [[ "$required" == "true" ]]; then
      mode="hard"
    else
      mode="soft"
    fi
  fi
  env_validate_var "$var" "$value" "$mode"
}

verify_variables() {
  validate_known_env_from_spec
  validate_template_env_values
  validate_unknown_game_settings_env_values
}

# Snapshot externally provided environment values (Docker/container env) BEFORE init_runtime_env exports config-derived env values.
# Used to disable editing of settings that are controlled by ENV and would be overwritten on bootstrap/container start.
declare -A MENU_EXTERNAL_ENV=()

menu_capture_external_env() {
  local var value line name

  while IFS= read -r var; do
    [[ -z "$var" ]] && continue
    value="$(printenv "$var" 2>/dev/null || true)"
    if [[ -n "$value" ]]; then
      MENU_EXTERNAL_ENV["$var"]="$value"
    fi
  done < <(validation_list_envs)

  # Pattern-based overrides (game settings + roles).
  while IFS= read -r line; do
    name="${line%%=*}"
    value="${line#*=}"
    case "$name" in
      ENSHROUDED_GS_*|ENSHROUDED_ROLE_*)
        if [[ -n "$value" ]]; then
          MENU_EXTERNAL_ENV["$name"]="$value"
        fi
        ;;
    esac
  done < <(env)
}

menu_capture_external_env
init_runtime_env


# --- inlined menu module: ui ---
# UI helpers for the interactive shell menu.
# Expected to be sourced after the menu runtime bootstrap so log helpers and colors exist.

ui_has_tty() {
  [[ -t 0 && -t 1 ]]
}

ui_clear() {
  if command -v clear >/dev/null 2>&1; then
    clear
  else
    printf "\n\n\n\n\n\n\n"
  fi
}

ui_hr() {
  printf "%s\n" "--------------------------------------------------------------------------------"
}

ui_banner() {
  printf "%s" "${C_MAGENTA}"
  cat <<'EOF'
>>=============================================================<<
|| __  __    _    _   _    _    ____ _____ ____    _           ||
|||  \/  |  / \  | \ | |  / \  / ___| ____|  _ \  | |__  _   _ ||
||| |\/| | / _ \ |  \| | / _ \| |  _|  _| | |_) | | '_ \| | | |||
||| |  | |/ ___ \| |\  |/ ___ \ |_| | |___|  _ <  | |_) | |_| |||
|||_|  |_/_/   \_\_| \_/_/   \_\____|_____|_| \_\ |_.__/ \__, |||
||| |__   ___  _ __  ___  __ _(_) |__   __ _ _   _  ___ _|___/ ||
||| '_ \ / _ \| '_ \/ __|/ _` | | '_ \ / _` | | | |/ _ \ '__|  ||
||| |_) | (_) | | | \__ \ (_| | | |_) | (_| | |_| |  __/ |     ||
|||_.__/ \___/|_| |_|___/\__,_|_|_.__/ \__,_|\__,_|\___|_|     ||
>>=============================================================<<
EOF
  printf "%s" "${C_RESET}"
  printf "%s\n" "${C_GREEN}                 Server Manager${C_RESET}"
  printf "%s\n" "${C_DIM}        Enshrouded Control Layer${C_RESET}"
  ui_hr
}

ui_kv() {
  local k v
  k="$1"
  v="$2"
  printf "%s: %s\n" "${C_DIM}${k}${C_RESET}" "$v"
}

ui_note() {
  printf "%s%s%s\n" "${C_DIM}" "$*" "${C_RESET}"
}

ui_error() {
  printf "%s%s%s\n" "${C_RED}" "$*" "${C_RESET}" >&2
}

ui_warn_line() {
  printf "%s%s%s\n" "${C_YELLOW}" "$*" "${C_RESET}"
}

ui_success() {
  printf "%s%s%s\n" "${C_GREEN}" "$*" "${C_RESET}"
}

ui_opt() {
  # Print a menu option with a colored key.
  # Usage: ui_opt 1 "Edit current settings"
  local key text
  key="$1"
  shift || true
  text="$*"
  printf "%s[%s]%s %s\n" "${C_MAGENTA}" "$key" "${C_RESET}" "$text"
}

ui_read() {
  local prompt value
  prompt="$1"
  if [[ -r /dev/tty ]]; then
    read -r -p "$prompt" value </dev/tty || true
  else
    read -r -p "$prompt" value || true
  fi
  printf "%s" "$value"
}

ui_pause() {
  local _unused
  if [[ -r /dev/tty ]]; then
    read -r -p "Press Enter to continue..." _unused </dev/tty || true
  else
    read -r -p "Press Enter to continue..." _unused || true
  fi
}

ui_confirm_yes_no() {
  local prompt ans normalized
  prompt="$1"
  while :; do
    ans="$(ui_read "$prompt [yes/no]: ")"
    normalized="$(echo "$ans" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$normalized" in
      y|yes|j|ja)
        return 0
        ;;
      n|no|nein|"")
        return 1
        ;;
      *)
        ui_warn_line "Please answer yes or no."
        ;;
    esac
  done
}

# Backwards-compatible alias (older call sites).
ui_confirm_ja_nein() {
  ui_confirm_yes_no "$@"
}

ui_prompt_number() {
  local prompt ans
  prompt="$1"
  while :; do
    ans="$(ui_read "$prompt: ")"
    ans="$(echo "$ans" | xargs)"
    if [[ "$ans" =~ ^[0-9]+$ ]]; then
      printf "%s" "$ans"
      return 0
    fi
    ui_warn_line "Please enter a number."
  done
}

ui_prompt_choice() {
  # Reads a raw choice (number or letter command) from the user.
  local prompt ans
  prompt="$1"
  ans="$(ui_read "$prompt: ")"
  ans="$(echo "$ans" | xargs)"
  printf "%s" "$ans"
}

ui_actions_bar() {
  # Nano-like action hint bar (simple, line-based).
  # Usage: ui_actions_bar "0 Back" "m Main" "x Exit"
  local item
  ui_hr
  printf "%s" "${C_MAGENTA}"
  printf "%s" "Actions:"
  for item in "$@"; do
    printf "  [%s]" "$item"
  done
  printf "%s\n" "${C_RESET}"
}

menu_nav_clear() { MENU_NAV=""; }
menu_nav_set() { MENU_NAV="$1"; }
menu_nav_is_set() { [[ -n "${MENU_NAV:-}" ]]; }
menu_nav_value() { printf "%s" "${MENU_NAV:-}"; }

menu_mountinfo_decode_path() {
  # /proc/self/mountinfo uses octal escapes for spaces, tabs, etc (e.g. \040).
  # Decode for display only.
  local raw
  raw="$1"
  printf "%b" "$raw"
}

menu_container_to_host_path() {
  # Best-effort conversion of a container path to the bind-mount source path as seen by the host.
  #
  # For bind mounts, /proc/self/mountinfo typically exposes the host path in the "root" field.
  # For named volumes, the root may point into Docker's data directory.
  local container_path line root_raw mp_raw root mp best_mp best_root rel
  container_path="$1"

  if [[ ! -r /proc/self/mountinfo ]]; then
    return 1
  fi

  best_mp=""
  best_root=""
  while IFS= read -r line; do
    # root and mount point are the 4th and 5th whitespace-separated fields.
    set -- $line
    root_raw="${4-}"
    mp_raw="${5-}"
    if [[ -z "$root_raw" || -z "$mp_raw" ]]; then
      continue
    fi

    root="$(menu_mountinfo_decode_path "$root_raw")"
    mp="$(menu_mountinfo_decode_path "$mp_raw")"

    if [[ "$container_path" == "$mp" || "$container_path" == "$mp/"* ]]; then
      if [[ ${#mp} -gt ${#best_mp} ]]; then
        best_mp="$mp"
        best_root="$root"
      fi
    fi
  done </proc/self/mountinfo

  # Avoid mapping to the container root filesystem (usually overlay).
  if [[ -z "$best_mp" || "$best_mp" == "/" || -z "$best_root" ]]; then
    return 1
  fi

  rel="${container_path#$best_mp}"
  if [[ -n "$rel" && "${rel:0:1}" != "/" ]]; then
    rel="/$rel"
  fi

  printf "%s%s" "${best_root%/}" "$rel"
  return 0
}

menu_display_path() {
  # Best-effort display of host path instead of container path.
  # Priority:
  # 1) HOST_INSTALL_PATH (explicit override)
  # 2) /proc/self/mountinfo mapping (bind mounts)
  local container_path host_path
  container_path="$1"

  if [[ -n "${HOST_INSTALL_PATH:-}" ]] && [[ "$container_path" == "$install_path"* ]]; then
    printf "%s%s" "${HOST_INSTALL_PATH%/}" "${container_path#$install_path}"
    return 0
  fi

  if host_path="$(menu_container_to_host_path "$container_path" 2>/dev/null)"; then
    if [[ -n "$host_path" ]]; then
      printf "%s" "$host_path"
      return 0
    fi
  fi

  printf "%s" "$container_path"
}

ui_header() {
  local subtitle
  subtitle="${1:-}"

  ui_clear
  ui_banner
  if [[ -n "$subtitle" ]]; then
    printf "\n%s%s%s\n" "${C_DIM}" "$subtitle" "${C_RESET}"
  fi

  # Status block (non-fatal if supervisorctl fails)
  local en_profile manager_profile server_status
  en_profile="$(enshrouded_profile_resolve 2>/dev/null || echo "default")"
  manager_profile="$(manager_profile_resolve 2>/dev/null || echo "default")"

  if checkRunning "server"; then
    server_status="${C_GREEN}RUNNING${C_RESET}"
  else
    server_status="${C_RED}STOPPED${C_RESET}"
  fi

  ui_kv "Enshrouded Profile" "${C_GREEN}${en_profile}${C_RESET}"
  ui_kv "Manager Profile" "${C_GREEN}${manager_profile}${C_RESET}"
  ui_kv "Server" "$server_status"
  ui_kv "Enshrouded Config" "$(menu_display_path "${install_path}/enshrouded_server.json")"
  ui_kv "Manager Config" "$(menu_display_path "$(manager_config_path)")"
  ui_hr

  if ui_has_tty; then
    ui_note "Navigation: enter a number (or command letter) and press Enter."
    ui_note "Exit behavior: if the server is STOPPED, you will be asked if it should be started."
  else
    ui_warn_line "Hint: no TTY detected. Start with: docker exec -it CONTAINER_NAME ctl menu"
  fi
  echo
}

menu_stop_server_now() {
  # Stop the Enshrouded server without asking (callers must confirm before invoking).
  if ! checkRunning "server"; then
    return 0
  fi

  supervisorctl stop server >/dev/null 2>&1 || true

  # Best-effort wait until supervisor reports it stopped.
  local deadline now
  deadline=$(( $(date +%s) + 30 ))
  while checkRunning "server"; do
    now="$(date +%s)"
    if [[ "$now" -ge "$deadline" ]]; then
      ui_error "Timeout while stopping server. Aborting."
      return 1
    fi
    sleep 1
  done

  return 0
}

menu_stop_server_for_config_change() {
  local reason
  reason="$1"

  if ! checkRunning "server"; then
    return 0
  fi

  ui_warn_line "The Enshrouded server is currently RUNNING."
  ui_warn_line "To $reason, the server must be stopped first to avoid conflicts."
  ui_warn_line "All players will be disconnected."
  echo

  if ! ui_confirm_yes_no "Stop server now?"; then
    ui_note "Cancelled."
    return 1
  fi

  if ! menu_stop_server_now; then
    return 1
  fi

  ui_success "server stopped."
  return 0
}

menu_prompt_start_server() {
  local prompt
  prompt="${1:-Start server now?}"

  if ui_confirm_yes_no "$prompt"; then
    supervisorctl start server >/dev/null 2>&1 || true
    ui_success "Server start requested."
  else
    ui_note "Server remains stopped."
  fi
}

menu_wait_for_program_exit() {
  local proc timeout deadline now
  proc="$1"
  timeout="${2:-600}"

  if ! checkRunning "$proc"; then
    return 0
  fi

  ui_note "Waiting for $proc to finish..."
  deadline=$(( $(date +%s) + timeout ))
  while checkRunning "$proc"; do
    now="$(date +%s)"
    if [[ "$now" -ge "$deadline" ]]; then
      ui_warn_line "Timeout while waiting for $proc."
      return 1
    fi
    sleep 1
  done

  return 0
}

menu_env_override_is_set() {
  local name
  name="$1"
  [[ -n "${MENU_EXTERNAL_ENV[$name]+x}" ]]
}

menu_env_override_value() {
  local name
  name="$1"
  printf "%s" "${MENU_EXTERNAL_ENV[$name]-}"
}

menu_env_override_pretty_value() {
  local name value max
  name="$1"
  value="$2"
  max=80

  if [[ "$name" == *_HOOK || "$name" == *HOOK* ]]; then
    if [[ -n "$value" ]]; then
      printf "%s" "<set>"
    fi
    return 0
  fi

  if [[ "${#value}" -gt "$max" ]]; then
    printf "%s..." "${value:0:$max}"
  else
    printf "%s" "$value"
  fi
}

menu_env_locked_badge() {
  local env_var
  env_var="$1"
  if menu_env_override_is_set "$env_var"; then
    printf " %s" "${C_RED}[ENV]${C_RESET}"
  fi
}

menu_warn_env_overrides_before_manager_profile_selection() {
  local any v value
  any="false"
  while IFS= read -r v; do
    [[ -z "$v" ]] && continue
    if menu_env_override_is_set "$v"; then
      any="true"
      break
    fi
  done < <(validation_list_envs_by_meta_field "managerJsonPath")

  if [[ "$any" != "true" ]]; then
    return 0
  fi

  ui_header "Environment Overrides Detected"
  ui_warn_line "Some Server Manager settings are controlled by environment variables."
  ui_warn_line "They will overwrite profile/template values on bootstrap or next container start."
  echo
  ui_note "Active overrides:"
  while IFS= read -r v; do
    [[ -z "$v" ]] && continue
    if menu_env_override_is_set "$v"; then
      value="$(menu_env_override_value "$v")"
      printf "%s=%s\n" "$v" "$(menu_env_override_pretty_value "$v" "$value")"
    fi
  done < <(validation_list_envs_by_meta_field "managerJsonPath")
  echo

  if ! ui_confirm_yes_no "Continue anyway?"; then
    ui_note "Cancelled."
    ui_pause
    return 1
  fi

  return 0
}

menu_warn_env_overrides_before_enshrouded_profile_selection() {
  local -a keys
  local k value

  keys=()
  for k in "${!MENU_EXTERNAL_ENV[@]}"; do
    case "$k" in
      ENSHROUDED_*)
        keys+=("$k")
        ;;
    esac
  done

  if [[ "${#keys[@]}" -eq 0 ]]; then
    return 0
  fi

  mapfile -t keys < <(printf "%s\n" "${keys[@]}" | sort)

  ui_header "Environment Overrides Detected"
  ui_warn_line "Some Enshrouded settings are controlled by environment variables."
  ui_warn_line "They will overwrite profile/template values on bootstrap or next container start."
  echo
  ui_note "Active overrides:"
  for k in "${keys[@]}"; do
    value="$(menu_env_override_value "$k")"
    printf "%s=%s\n" "$k" "$(menu_env_override_pretty_value "$k" "$value")"
  done
  echo

  if ! ui_confirm_yes_no "Continue anyway?"; then
    ui_note "Cancelled."
    ui_pause
    return 1
  fi

  return 0
}

menu_requests_dir() {
  # Store job requests on the persistent volume so supervisor jobs can pick them up.
  printf "%s/requests" "$MANAGER_DATA_DIR"
}

menu_write_request_json() {
  # Write a JSON request file (atomic via tmp+mv) and return its path on stdout.
  # Usage: menu_write_request_json <filename> <jq -n args...>
  local name dir file tmp
  name="$1"
  shift

  dir="$(menu_requests_dir)"
  mkdir -p "$dir" 2>/dev/null || true
  file="${dir}/${name}"
  tmp="$(mktemp "${dir}/.${name}.XXXXXX")"

  if jq -n "$@" >"$tmp" 2>/dev/null; then
    mv -f "$tmp" "$file"
    chmod 600 "$file" 2>/dev/null || true
    chown enshrouded:enshrouded "$file" 2>/dev/null || true
    printf "%s" "$file"
    return 0
  fi

  rm -f "$tmp" 2>/dev/null || true
  return 1
}

menu_run_backup_job() {
  # Trigger unified backup job with request payload.
  # Usage:
  #   menu_run_backup_job <mode> <timeout> <includeSavegame> <includeEnshroudedConfig> <includeManagerConfig> [cleanup]
  local mode timeout include_savegame include_ens include_mgr cleanup
  mode="${1:-manual}"
  timeout="${2:-30}"
  include_savegame="${3:-true}"
  include_ens="${4:-true}"
  include_mgr="${5:-true}"
  cleanup="${6:-false}"

  if ! menu_write_request_json "backup.json" \
    --arg mode "$mode" \
    --argjson includeSavegame "$include_savegame" \
    --argjson includeEnshroudedConfig "$include_ens" \
    --argjson includeManagerConfig "$include_mgr" \
    --argjson cleanup "$cleanup" \
    '{mode: $mode, includeSavegame: $includeSavegame, includeEnshroudedConfig: $includeEnshroudedConfig, includeManagerConfig: $includeManagerConfig, cleanup: $cleanup}' >/dev/null; then
    ui_error "Failed to write backup request."
    return 1
  fi

  supervisorctl start backup >/dev/null 2>&1 || true
  if ! menu_wait_for_program_exit "backup" "$timeout"; then
    ui_warn_line "Timeout while waiting for backup."
    ui_note "Check: supervisorctl status backup"
    return 1
  fi

  return 0
}

menu_run_config_backup_job() {
  # Selector wrapper used by editors for config-only backups.
  # Config-only backups are written under BACKUP_DIR/manual (without savegame files).
  local selector timeout include_ens include_mgr
  selector="${1:-manual:all}"
  timeout="${2:-30}"
  include_ens="true"
  include_mgr="true"

  case "$selector" in
    manual:enshrouded|enshrouded)
      include_ens="true"
      include_mgr="false"
      ;;
    manual:manager|manager)
      include_ens="false"
      include_mgr="true"
      ;;
    manual:all|all)
      include_ens="true"
      include_mgr="true"
      ;;
    *)
      ui_warn_line "Unknown config backup selector: $selector"
      return 1
      ;;
  esac

  menu_run_backup_job "manual" "$timeout" "false" "$include_ens" "$include_mgr" "false"
}


# --- inlined menu module: backups ---
menu_save_dir_resolve() {
  local dir
  dir="${ENSHROUDED_SAVE_DIR:-./savegame}"
  if [[ "$dir" == /* ]]; then
    printf "%s" "$dir"
  else
    printf "%s/%s" "$install_path" "$dir"
  fi
}

menu_backup_kind_from_path() {
  local backup_root rel
  backup_root="$(backup_dir_resolve)"
  rel="${1#$backup_root/}"
  case "$rel" in
    scheduled/*) echo "scheduled" ;;
    manual/*) echo "manual" ;;
    *) echo "manual" ;;
  esac
}

menu_backup_list_files() {
  local backup_root
  backup_root="$(backup_dir_resolve)"

  {
    find "${backup_root}/manual" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
    find "${backup_root}/scheduled" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
  } | sort -rn | cut -f2-
}

menu_backup_zip_entries() {
  local zip_file
  zip_file="$1"

  python3 - "$zip_file" <<'PY'
import pathlib
import sys
import zipfile

zip_path = pathlib.Path(sys.argv[1])
try:
    with zipfile.ZipFile(zip_path, "r") as zf:
        for name in zf.namelist():
            print(name)
except Exception:
    pass
PY
}

menu_backup_detect_components() {
  local zip_file entries has_savegame has_enshrouded has_manager
  zip_file="$1"
  entries="$(menu_backup_zip_entries "$zip_file")"
  has_savegame="false"
  has_enshrouded="false"
  has_manager="false"

  if printf '%s\n' "$entries" | grep -q '^savegame/'; then
    has_savegame="true"
  fi

  if printf '%s\n' "$entries" | grep -Fxq "config/enshrouded_server.json"; then
    has_enshrouded="true"
  fi

  if printf '%s\n' "$entries" | grep -Fxq "config/server_manager.json"; then
    has_manager="true"
  fi

  printf "%s %s %s" "$has_savegame" "$has_enshrouded" "$has_manager"
}

menu_run_savegame_backup() {
  local backup_dir save_dir
  backup_dir="$(backup_dir_resolve)"
  save_dir="$(menu_save_dir_resolve)"

  ui_header "Create Manual Backup"
  ui_note "Manual backups are stored under BACKUP_DIR/manual and are never pruned by backupMaxCount."
  echo
  ui_kv "Save Directory" "$save_dir"
  ui_kv "Backup Root" "$backup_dir"
  ui_kv "Target Folder" "${backup_dir}/manual"
  echo

  if ! ui_confirm_yes_no "Create manual full backup now?"; then
    ui_note "Cancelled."
    ui_pause
    return 0
  fi

  if menu_run_backup_job "manual" 1200 "true" "true" "true" "false"; then
    ui_success "Manual backup created."
  else
    ui_warn_line "Backup failed or timed out."
  fi

  ui_pause
  return 0
}

menu_run_config_backup_now() {
  local choice include_ens include_mgr
  include_ens="true"
  include_mgr="true"

  while :; do
    ui_header "Create Config Backup"
    ui_note "Creates a config-only ZIP under BACKUP_DIR/manual."
    echo
    ui_opt 1 "Enshrouded config only"
    ui_opt 2 "Server Manager config only"
    ui_opt 3 "Both config files"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1)
        include_ens="true"
        include_mgr="false"
        ;;
      2)
        include_ens="false"
        include_mgr="true"
        ;;
      3)
        include_ens="true"
        include_mgr="true"
        ;;
      0)
        return 0
        ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        continue
        ;;
    esac

    if menu_run_backup_job "manual" 120 "false" "$include_ens" "$include_mgr" "false"; then
      ui_success "Config backup created."
    else
      ui_warn_line "Config backup failed or timed out."
    fi
    ui_pause
    return 0
  done
}

menu_restore_backup() {
  local backup_root save_dir selected choice file
  backup_root="$(backup_dir_resolve)"
  save_dir="$(menu_save_dir_resolve)"

  while :; do
    local -a files
    mapfile -t files < <(menu_backup_list_files)

    ui_header "Restore Backup"
    ui_kv "Backup Root" "$backup_root"
    ui_kv "Target Save Directory" "$save_dir"
    ui_kv "Savefile Name" "$savefile_name"
    echo

    if [[ "${#files[@]}" -eq 0 ]]; then
      ui_warn_line "No backup ZIP files found."
      echo
      if ui_confirm_yes_no "Create a manual backup now?"; then
        menu_run_savegame_backup || true
        continue
      fi
      return 0
    fi

    ui_note "Backups (newest first):"
    echo
    local idx base kind
    idx=1
    for file in "${files[@]}"; do
      base="$(basename "$file")"
      kind="$(menu_backup_kind_from_path "$file")"
      printf "%s[%s]%s %-11s %s\n" "${C_MAGENTA}" "$idx" "${C_RESET}" "${kind}" "$base"
      idx=$((idx + 1))
    done
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Backup")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0)
        return 0
        ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "${#files[@]}" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    selected="${files[$((choice - 1))]}"

    local has_savegame has_enshrouded has_manager
    read -r has_savegame has_enshrouded has_manager <<<"$(menu_backup_detect_components "$selected")"
    if [[ "$has_savegame" != "true" && "$has_enshrouded" != "true" && "$has_manager" != "true" ]]; then
      ui_warn_line "No restorable components detected in this backup."
      ui_pause
      continue
    fi

    ui_header "Restore Backup"
    ui_warn_line "WARNING: Selected components will overwrite current data."
    ui_warn_line "The server will be stopped and players disconnected."
    echo
    ui_kv "Selected Backup" "$(basename "$selected")"
    ui_kv "Detected Components" "savegame=$has_savegame, enshrouded=$has_enshrouded, manager=$has_manager"
    echo

    if ! ui_confirm_yes_no "Continue to component selection?"; then
      ui_note "Cancelled."
      ui_pause
      continue
    fi

    local restore_savegame restore_enshrouded restore_manager safety
    restore_savegame="false"
    restore_enshrouded="false"
    restore_manager="false"
    safety="false"

    if [[ "$has_savegame" == "true" ]] && ui_confirm_yes_no "Restore savegame files?"; then
      restore_savegame="true"
    fi
    if [[ "$has_enshrouded" == "true" ]] && ui_confirm_yes_no "Restore enshrouded_server.json?"; then
      restore_enshrouded="true"
    fi
    if [[ "$has_manager" == "true" ]] && ui_confirm_yes_no "Restore server_manager.json?"; then
      restore_manager="true"
    fi

    if [[ "$restore_savegame" != "true" && "$restore_enshrouded" != "true" && "$restore_manager" != "true" ]]; then
      ui_warn_line "Nothing selected for restore."
      ui_pause
      continue
    fi

    if ui_confirm_yes_no "Create safety backup before restore?"; then
      safety="true"
    fi

    if ! menu_write_request_json "backup_restore.json" \
      --arg zipPath "$selected" \
      --argjson restoreSavegame "$restore_savegame" \
      --argjson restoreEnshroudedConfig "$restore_enshrouded" \
      --argjson restoreManagerConfig "$restore_manager" \
      --argjson createSafetyBackup "$safety" \
      '{zipPath: $zipPath, restoreSavegame: $restoreSavegame, restoreEnshroudedConfig: $restoreEnshroudedConfig, restoreManagerConfig: $restoreManagerConfig, createSafetyBackup: $createSafetyBackup}' >/dev/null; then
      ui_error "Failed to write restore request."
      ui_pause
      continue
    fi

    supervisorctl start restore-backup >/dev/null 2>&1 || true
    if ! menu_wait_for_program_exit "restore-backup" 1200; then
      ui_warn_line "Timeout while waiting for restore-backup."
      ui_note "Check: supervisorctl status restore-backup"
      ui_pause
      continue
    fi

    ui_success "Restore finished."
    echo
    menu_prompt_start_server "Start server now?"
    ui_pause
    return 0
  done
}

menu_backups_menu() {
  local choice
  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Backups"

    ui_opt 1 "Restore from backup ZIP"
    ui_opt 2 "Create manual full backup now"
    ui_opt 3 "Create config backup now"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1) menu_restore_backup || true ;;
      2) menu_run_savegame_backup || true ;;
      3) menu_run_config_backup_now || true ;;
      0) return 0 ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        ;;
    esac
  done
}


# --- inlined menu module: editor_spec_json ---
# Generic, spec-driven JSON editor helpers for the interactive menu.
# Driven by `server_manager/env/env_server_manager.json` and
# `server_manager/env/env_enshrouded_server.json` meta mappings.

menu_spec_editor__json_get_scalar() {
  # Prints the scalar as a string, but keeps `false` and `0` visible.
  local file path
  file="$1"
  path="$2"
  jq -r "$path | if . == null then empty else tostring end" "$file" 2>/dev/null || echo ""
}

menu_spec_editor__json_get_csv_list() {
  # Prints a CSV representation of a JSON array (used for list env values).
  local file path
  file="$1"
  path="$2"
  jq -r "$path // [] | if type == \"array\" then join(\",\") else empty end" "$file" 2>/dev/null || echo ""
}

menu_spec_editor__session_backup_if_needed() {
  # Create exactly one config backup per edit session (first write wins).
  # Uses dynamic scope: the calling editor sets `backed_up=false` locally.
  local backup_job timeout
  backup_job="${1-}"
  timeout="${2:-30}"

  if [[ -z "$backup_job" ]]; then
    return 0
  fi
  if [[ "${backed_up:-false}" == "true" ]]; then
    return 0
  fi
  if ! declare -F menu_run_config_backup_job >/dev/null 2>&1; then
    backed_up="true"
    return 0
  fi

  ui_note "Creating config backup (logged via Supervisor)..."
  menu_run_config_backup_job "$backup_job" "$timeout" || true
  backed_up="true"
  return 0
}

menu_spec_editor__set_jq() {
  # Apply a jq transform to $file atomically.
  local file tmp
  file="$1"
  shift

  tmp="$(mktemp)"
  if jq "$@" "$file" >"$tmp"; then
    mv "$tmp" "$file"
    chmod 600 "$file" 2>/dev/null || true
    chown enshrouded:enshrouded "$file" 2>/dev/null || true
    return 0
  fi
  rm -f "$tmp" 2>/dev/null || true
  return 1
}

menu_spec_editor__block_if_env_locked() {
  # Returns 0 if editable, 1 if locked by external env override.
  local env_var env_value
  env_var="$1"

  if ! declare -F menu_env_override_is_set >/dev/null 2>&1; then
    return 0
  fi
  if ! menu_env_override_is_set "$env_var"; then
    return 0
  fi

  env_value="$(menu_env_override_value "$env_var")"
  ui_warn_line "This setting is controlled by an environment variable and cannot be edited here."
  ui_kv "ENV" "$env_var=$(menu_env_override_pretty_value "$env_var" "$env_value")"
  ui_note "Remove it from your docker-compose/container environment to edit this value."
  ui_pause
  return 1
}

menu_spec_editor__display_value_for_var() {
  local file env_var json_path empty_label rule
  file="$1"
  env_var="$2"
  json_path="$3"
  empty_label="${4:-<empty>}"

  if menu_env_override_is_set "$env_var"; then
    local raw
    raw="$(menu_env_override_value "$env_var")"
    if [[ -z "$raw" ]]; then
      printf "%s" "${C_DIM}${empty_label}${C_RESET}"
    else
      printf "%s%s%s" "${C_RED}" "$raw" "${C_RESET}"
    fi
    return 0
  fi

  rule="$(validation_rule_json "$env_var" 2>/dev/null || true)"
  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    local csv
    csv="$(menu_spec_editor__json_get_csv_list "$file" "$json_path")"
    if [[ -z "$csv" ]]; then
      printf "%s" "${C_DIM}${empty_label}${C_RESET}"
    else
      printf "%s%s%s" "${C_GREEN}" "$csv" "${C_RESET}"
    fi
    return 0
  fi

  local raw
  raw="$(menu_spec_editor__json_get_scalar "$file" "$json_path")"
  if [[ -z "$raw" ]]; then
    printf "%s" "${C_DIM}${empty_label}${C_RESET}"
  else
    printf "%s%s%s" "${C_GREEN}" "$raw" "${C_RESET}"
  fi
}

menu_spec_editor__prompt_value() {
  # Prompts for a new value. Prints the raw input to stdout.
  local env_var label current empty_action bool_toggle
  env_var="$1"
  label="$2"
  current="$3"
  empty_action="${4:-cancel}"   # cancel|null|clear_list
  bool_toggle="${5:-false}"

  local type desc hint required allow_empty
  type="$(validation_env_type "$env_var" 2>/dev/null || true)"
  [[ -z "$type" ]] && type="string"

  echo
  ui_kv "Field" "$label"
  ui_kv "Current" "${current:-<empty>}"
  desc="$(validation_env_description "$env_var" 2>/dev/null || true)"
  hint="$(validation_env_allowed_hint "$env_var" 2>/dev/null || true)"
  [[ -n "$desc" ]] && ui_note "$desc"
  [[ -n "$hint" ]] && ui_note "$hint"

  required="$(validation_env_required "$env_var" 2>/dev/null || true)"
  allow_empty="$(validation_env_allow_empty "$env_var" 2>/dev/null || echo "true")"
  if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
    ui_note "Enter = toggle"
  else
    if [[ "$required" == "true" ]]; then
      ui_note "Empty is not allowed"
    else
      case "$empty_action" in
        null)
          if [[ "$allow_empty" == "true" ]]; then
            ui_note "Empty = null"
          else
            ui_note "Empty is not allowed"
          fi
          ;;
        clear_list)
          if [[ "$allow_empty" == "true" ]]; then
            ui_note "Empty = clear"
          else
            ui_note "Empty is not allowed"
          fi
          ;;
        *)
          ui_note "Empty = cancel"
          ;;
      esac
    fi
  fi
  echo

  local value normalized
  value="$(ui_read "New value: ")"
  value="$(echo "$value" | xargs)"

  # Normalize booleans for convenience.
  if [[ "$type" == "bool" ]]; then
    normalized="$(echo "$value" | tr '[:upper:]' '[:lower:]')"
    case "$normalized" in
      1|ja|j|y|yes) value="true" ;;
      0|nein|n|no) value="false" ;;
      true|false) value="$normalized" ;;
    esac
  fi

  printf "%s" "$value"
}

menu_spec_editor__edit_var() {
  # Edit a single mapped var using the validation spec for type, description and allowed hints.
  local file meta_field env_var json_path label empty_action backup_job bool_toggle
  file="$1"
  meta_field="$2"
  env_var="$3"
  label="$4"
  empty_action="${5:-cancel}"
  backup_job="${6-}"
  bool_toggle="${7:-false}"

  if ! menu_spec_editor__block_if_env_locked "$env_var"; then
    return 0
  fi

  json_path="$(validation_env_meta_field "$env_var" "$meta_field" 2>/dev/null || true)"
  if [[ -z "$json_path" ]]; then
    ui_warn_line "No config mapping for: $env_var"
    ui_pause
    return 0
  fi

  local rule type current v normalized
  rule="$(validation_rule_json "$env_var" 2>/dev/null || true)"
  type="$(validation_env_type "$env_var" 2>/dev/null || echo "string")"
  [[ -z "$type" ]] && type="string"

  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    current="$(menu_spec_editor__json_get_csv_list "$file" "$json_path")"
    v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "clear_list" "false")"
    if [[ -z "$v" ]]; then
      if ! validation_check "$env_var" ""; then
        ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
        ui_pause
        return 0
      fi
      menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
      menu_spec_editor__set_jq "$file" "$json_path = []" || true
      return 0
    fi
    if ! validation_check "$env_var" "$v"; then
      ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
      ui_pause
      return 0
    fi
    menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
    menu_spec_editor__set_jq "$file" --arg val "$v" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))" || true
    return 0
  fi

  current="$(menu_spec_editor__json_get_scalar "$file" "$json_path")"

  if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
    [[ -z "$current" ]] && current="false"
  fi

  v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "$empty_action" "$bool_toggle")"
  if [[ -z "$v" ]]; then
    if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
      if [[ "$current" == "true" ]]; then
        v="false"
      else
        v="true"
      fi
    else
      if [[ "$empty_action" == "null" ]]; then
        if ! validation_check "$env_var" ""; then
          ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
          ui_pause
          return 0
        fi
        menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
        menu_spec_editor__set_jq "$file" "$json_path = null" || true
      fi
      return 0
    fi
  fi

  if ! validation_check "$env_var" "$v"; then
    ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
    ui_pause
    return 0
  fi

  local jq_arg
  case "$type" in
    bool|int|number) jq_arg="--argjson" ;;
    *) jq_arg="--arg" ;;
  esac

  menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
  menu_spec_editor__set_jq "$file" "$jq_arg" val "$v" "$json_path = \$val" || true
}

menu_spec_editor__edit_var_at_path() {
  # Like menu_spec_editor__edit_var, but takes an explicit JSON path instead of a meta mapping.
  local file env_var json_path label empty_action backup_job bool_toggle
  file="$1"
  env_var="$2"
  json_path="$3"
  label="$4"
  empty_action="${5:-cancel}"
  backup_job="${6-}"
  bool_toggle="${7:-false}"

  if ! menu_spec_editor__block_if_env_locked "$env_var"; then
    return 0
  fi
  if [[ -z "$json_path" ]]; then
    ui_warn_line "No config mapping for: $env_var"
    ui_pause
    return 0
  fi

  local rule type current v
  rule="$(validation_rule_json "$env_var" 2>/dev/null || true)"
  type="$(validation_env_type "$env_var" 2>/dev/null || echo "string")"
  [[ -z "$type" ]] && type="string"

  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    current="$(menu_spec_editor__json_get_csv_list "$file" "$json_path")"
    v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "clear_list" "false")"
    if [[ -z "$v" ]]; then
      if ! validation_check "$env_var" ""; then
        ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
        ui_pause
        return 0
      fi
      menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
      menu_spec_editor__set_jq "$file" "$json_path = []" || true
      return 0
    fi
    if ! validation_check "$env_var" "$v"; then
      ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
      ui_pause
      return 0
    fi
    menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
    menu_spec_editor__set_jq "$file" --arg val "$v" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))" || true
    return 0
  fi

  current="$(menu_spec_editor__json_get_scalar "$file" "$json_path")"
  if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
    [[ -z "$current" ]] && current="false"
  fi

  v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "$empty_action" "$bool_toggle")"
  if [[ -z "$v" ]]; then
    if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
      if [[ "$current" == "true" ]]; then
        v="false"
      else
        v="true"
      fi
    else
      if [[ "$empty_action" == "null" ]]; then
        if ! validation_check "$env_var" ""; then
          ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
          ui_pause
          return 0
        fi
        menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
        menu_spec_editor__set_jq "$file" "$json_path = null" || true
      fi
      return 0
    fi
  fi

  if ! validation_check "$env_var" "$v"; then
    ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
    ui_pause
    return 0
  fi

  local jq_arg
  case "$type" in
    bool|int|number) jq_arg="--argjson" ;;
    *) jq_arg="--arg" ;;
  esac

  menu_spec_editor__session_backup_if_needed "$backup_job" 30 || true
  menu_spec_editor__set_jq "$file" "$jq_arg" val "$v" "$json_path = \$val" || true
}

menu_spec_editor__template_index_locked_badge() {
  # Prints a group-level [ENV] badge if any field in the template is controlled by ENV.
  local template env_prefix idx field env_var
  template="$1"
  env_prefix="$2"
  idx="$3"

  if ! declare -F menu_env_override_is_set >/dev/null 2>&1; then
    return 0
  fi

  while IFS= read -r field; do
    [[ -z "$field" ]] && continue
    env_var="${env_prefix}_${idx}_${field}"
    if menu_env_override_is_set "$env_var"; then
      printf " %s" "${C_RED}[ENV]${C_RESET}"
      return 0
    fi
  done < <(validation_list_template_fields "$template")

  return 0
}

menu_spec_editor__user_groups_edit_group() {
  local file g template env_prefix backup_job empty_label
  file="$1"
  g="$2"
  template="${3:-ENSHROUDED_ROLE}"
  env_prefix="${4:-ENSHROUDED_ROLE}"
  backup_job="${5:-manual:enshrouded}"
  empty_label="${6:-<empty>}"

  local base
  base=".userGroups[$g]"

  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    local current_name
    current_name="$(jq -r "$base.name | if . == null or . == \"\" then \"Group $g\" else . end" "$file" 2>/dev/null || echo "Group $g")"

    ui_header "User Group: $current_name"
    ui_note "Changes are written immediately."
    ui_note "[ENV] = controlled by container environment (locked)"
    echo

    local field_count last_group field env_var json_key json_path group label
    local -a fields
    fields=()
    field_count=0
    last_group=""

    while IFS= read -r field; do
      [[ -z "$field" ]] && continue

      env_var="${env_prefix}_${g}_${field}"
      json_key="$(validation_snake_to_lower_camel "$field")"
      json_path="${base}.${json_key}"
      label="$json_key"

      group="$(validation_env_meta_field "$env_var" "menuGroup" 2>/dev/null || true)"
      if [[ "$group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${group:-Settings} ==${C_RESET}"
        last_group="$group"
      fi

      fields+=("$field")
      field_count=$((field_count + 1))

      printf "%s[%s]%s %-22s %s%s\n" \
        "${C_MAGENTA}" "$field_count" "${C_RESET}" "$label" \
        "$(menu_spec_editor__display_value_for_var "$file" "$env_var" "$json_path" "$empty_label")" \
        "$(menu_env_locked_badge "$env_var")"
    done < <(validation_list_template_fields "$template")

    if [[ "$field_count" -le 0 ]]; then
      ui_warn_line "No role fields found in validation spec."
      ui_pause
      return 0
    fi

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    local choice
    choice="$(ui_prompt_choice "Field")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$field_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    field="${fields[$((choice - 1))]}"
    env_var="${env_prefix}_${g}_${field}"
    json_key="$(validation_snake_to_lower_camel "$field")"
    json_path="${base}.${json_key}"
    label="$json_key"

    local type empty_action bool_toggle
    type="$(validation_env_type "$env_var" 2>/dev/null || echo "string")"
    empty_action="cancel"
    bool_toggle="false"
    if [[ "$type" == "bool" ]]; then
      bool_toggle="true"
    fi
    if [[ "$field" == "PASSWORD" ]]; then
      empty_action="null"
      bool_toggle="false"
    fi

    menu_spec_editor__edit_var_at_path "$file" "$env_var" "$json_path" "$label" "$empty_action" "$backup_job" "$bool_toggle" || true
  done
}

menu_edit_user_groups_from_spec() {
  # Spec-driven editor for `.userGroups` driven by `templates.ENSHROUDED_ROLE`.
  local file template env_prefix backup_job empty_label
  file=""
  template="ENSHROUDED_ROLE"
  env_prefix="ENSHROUDED_ROLE"
  backup_job="manual:enshrouded"
  empty_label="<empty>"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --template)
        template="${2-}"
        shift 2
        ;;
      --envPrefix|--env-prefix)
        env_prefix="${2-}"
        shift 2
        ;;
      --backupJob|--backup-job)
        backup_job="${2-}"
        shift 2
        ;;
      --emptyLabel|--empty-label)
        empty_label="${2-}"
        shift 2
        ;;
      *)
        ui_warn_line "Unknown arg: $1"
        ui_pause
        return 1
        ;;
    esac
  done

  if [[ -z "$file" ]]; then
    ui_warn_line "menu_edit_user_groups_from_spec: missing --file"
    ui_pause
    return 1
  fi

  local choice count idx name
  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    ui_header "Edit User Groups"
    ui_note "[ENV] = controlled by container environment (locked)"

    count="$(jq -r '(.userGroups // []) | if type == "array" then length else 0 end' "$file" 2>/dev/null || echo 0)"
    if ! [[ "$count" =~ ^[0-9]+$ ]]; then
      count=0
    fi

    if [[ "$count" -le 0 ]]; then
      ui_warn_line "No userGroups found."
      echo
      ui_actions_bar "0 Back" "m Main" "x Exit"
      echo
      choice="$(ui_prompt_choice "Choice")"
      choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
      case "$choice" in
        0) return 0 ;;
        m) menu_nav_set "main"; return 0 ;;
        x|q) menu_nav_set "exit"; return 0 ;;
      esac
      continue
    fi

    local -a options
    options=()

    for idx in $(seq 0 $((count - 1))); do
      name="$(jq -r ".userGroups[$idx].name | if . == null or . == \"\" then \"Group $idx\" else . end" "$file" 2>/dev/null || echo "Group $idx")"
      options+=("$idx")
      printf "%s[%s]%s %s%s%s\n" \
        "${C_MAGENTA}" "$((idx + 1))" "${C_RESET}" \
        "${C_GREEN}" "$name" "${C_RESET}$(menu_spec_editor__template_index_locked_badge "$template" "$env_prefix" "$idx")"
    done

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Group")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    local g
    g=$((choice - 1))
    if [[ "$g" -lt 0 || "$g" -ge "$count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    menu_spec_editor__user_groups_edit_group "$file" "$g" "$template" "$env_prefix" "$backup_job" "$empty_label" || true
  done
}

menu_edit_json_from_spec() {
  # Interactive spec-driven editor.
  #
  # Required args:
  #   --title <title>
  #   --file <json_file>
  #   --metaField <meta_field>         # e.g. managerJsonPath, enshroudedMenuJsonPath, enshroudedJsonPath
  #
  # Optional args:
  #   --labelMode var|path             # how to render field labels (default: var)
  #   --labelStripPrefix <prefix>      # when labelMode=path, strip this prefix from the JSON path
  #   --filterPrefix <jsonPathPrefix>  # only include env values where jsonPath starts with this prefix
  #   --backupJob <supervisor_job>     # create one backup per edit session on first write
  #   --emptyAction cancel|null        # empty input behavior for scalar values (default: cancel)
  #   --boolToggle true|false          # allow empty input to toggle bools (default: false)
  #   --emptyLabel <text>              # placeholder for empty values (default: <empty>)
  #   --extra <token> <label> <group> <callback_fn>
  local title file meta_field label_mode label_strip_prefix filter_prefix backup_job empty_action bool_toggle empty_label
  title=""
  file=""
  meta_field=""
  label_mode="var"
  label_strip_prefix=""
  filter_prefix=""
  backup_job=""
  empty_action="cancel"
  bool_toggle="false"
  empty_label="<empty>"

  local -a extra_tokens extra_labels extra_groups extra_callbacks
  extra_tokens=()
  extra_labels=()
  extra_groups=()
  extra_callbacks=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        title="${2-}"
        shift 2
        ;;
      --file)
        file="${2-}"
        shift 2
        ;;
      --metaField|--meta-field|--meta)
        meta_field="${2-}"
        shift 2
        ;;
      --labelMode|--label-mode)
        label_mode="${2-}"
        shift 2
        ;;
      --labelStripPrefix|--label-strip-prefix)
        label_strip_prefix="${2-}"
        shift 2
        ;;
      --filterPrefix|--filter-prefix)
        filter_prefix="${2-}"
        shift 2
        ;;
      --backupJob|--backup-job)
        backup_job="${2-}"
        shift 2
        ;;
      --emptyAction|--empty-action)
        empty_action="${2-}"
        shift 2
        ;;
      --boolToggle|--bool-toggle)
        bool_toggle="${2-}"
        shift 2
        ;;
      --emptyLabel|--empty-label)
        empty_label="${2-}"
        shift 2
        ;;
      --extra)
        extra_tokens+=("${2-}")
        extra_labels+=("${3-}")
        extra_groups+=("${4-}")
        extra_callbacks+=("${5-}")
        shift 5
        ;;
      *)
        ui_warn_line "Unknown arg: $1"
        ui_pause
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$meta_field" ]]; then
    ui_warn_line "menu_edit_json_from_spec: missing --file or --metaField"
    ui_pause
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    ui_header "${title:-Edit Settings}"
    if declare -F menu_display_path >/dev/null 2>&1; then
      ui_kv "File" "$(menu_display_path "$file")"
    else
      ui_kv "File" "$file"
    fi
    ui_note "Changes are written immediately."
    ui_note "[ENV] = controlled by container environment (locked)"
    echo

    local field_count last_group var json_path group label
    local -a options
    options=()
    field_count=0
    last_group=""

    while IFS= read -r var; do
      [[ -z "$var" ]] && continue
      json_path="$(validation_env_meta_field "$var" "$meta_field" 2>/dev/null || true)"
      [[ -z "$json_path" ]] && continue

      if [[ -n "$filter_prefix" ]]; then
        case "$json_path" in
          "${filter_prefix}"*) ;;
          *) continue ;;
        esac
      fi

      group="$(validation_env_meta_field "$var" "menuGroup" 2>/dev/null || true)"
      case "$label_mode" in
        path)
          label="$json_path"
          if [[ -n "$label_strip_prefix" ]]; then
            label="${label#${label_strip_prefix}}"
          fi
          label="${label#.}"
          ;;
        *)
          label="$var"
          ;;
      esac

      if [[ "$group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${group:-Settings} ==${C_RESET}"
        last_group="$group"
      fi

      options+=("$var")
      field_count=$((field_count + 1))
      printf "%s[%s]%s %-26s %s%s\n" "${C_MAGENTA}" "$field_count" "${C_RESET}" "$label" "$(menu_spec_editor__display_value_for_var "$file" "$var" "$json_path" "$empty_label")" "$(menu_env_locked_badge "$var")"
    done < <(validation_list_envs_by_meta_field_ordered "$meta_field" "menuOrder")

    local i token extra_label extra_group cb
    for i in "${!extra_tokens[@]}"; do
      token="${extra_tokens[$i]}"
      extra_label="${extra_labels[$i]}"
      extra_group="${extra_groups[$i]}"
      cb="${extra_callbacks[$i]}"
      [[ -z "$token" || -z "$extra_label" || -z "$cb" ]] && continue

      if [[ "$extra_group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${extra_group:-Settings} ==${C_RESET}"
        last_group="$extra_group"
      fi

      options+=("$token")
      field_count=$((field_count + 1))
      printf "%s[%s]%s %-26s %s\n" "${C_MAGENTA}" "$field_count" "${C_RESET}" "$extra_label" "${C_DIM}<enter>${C_RESET}"
    done

    if [[ "$field_count" -le 0 ]]; then
      ui_warn_line "No settings found in validation spec."
      ui_pause
      return 0
    fi

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    local choice
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$field_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    local selected
    selected="${options[$((choice - 1))]}"

    # Extra entry?
    cb=""
    for i in "${!extra_tokens[@]}"; do
      if [[ "${extra_tokens[$i]}" == "$selected" ]]; then
        cb="${extra_callbacks[$i]}"
        break
      fi
    done

    if [[ -n "$cb" ]]; then
      "$cb" "$file" || true
      continue
    fi

    # Spec var.
    json_path="$(validation_env_meta_field "$selected" "$meta_field" 2>/dev/null || true)"
    case "$label_mode" in
      path)
        label="$json_path"
        if [[ -n "$label_strip_prefix" ]]; then
          label="${label#${label_strip_prefix}}"
        fi
        label="${label#.}"
        ;;
      *)
        label="$selected"
        ;;
    esac
    menu_spec_editor__edit_var "$file" "$meta_field" "$selected" "$label" "$empty_action" "$backup_job" "$bool_toggle" || true
  done
}


# --- inlined menu module: enshrouded ---
enshrouded_config_path() {
  printf "%s/enshrouded_server.json" "$install_path"
}

enshrouded_editor_jq_ok() {
  local file
  file="$1"
  jq -e 'type == "object"' "$file" >/dev/null 2>&1
}

enshrouded_editor_game_settings_menu() {
  local file
  file="$1"
  menu_edit_json_from_spec \
    --title "Edit Game Settings" \
    --file "$file" \
    --metaField "enshroudedJsonPath" \
    --labelMode "path" \
    --labelStripPrefix ".gameSettings." \
    --filterPrefix ".gameSettings." \
    --backupJob "manual:enshrouded" \
    --emptyAction "cancel" \
    --boolToggle "false" \
    --emptyLabel "<empty>"
}

enshrouded_editor_user_groups_menu() {
  local file
  file="$1"
  menu_edit_user_groups_from_spec \
    --file "$file" \
    --template "ENSHROUDED_ROLE" \
    --envPrefix "ENSHROUDED_ROLE" \
    --backupJob "manual:enshrouded" \
    --emptyLabel "<empty>"
}

editor_enshrouded_json() {
  local config_file backed_up
  config_file="$(enshrouded_config_path)"
  backed_up="false"

  if [[ ! -f "$config_file" ]]; then
    ui_warn_line "enshrouded_server.json is missing. Creating from profile..."
    ensure_enshrouded_config_from_profile || true
  fi

  if [[ ! -f "$config_file" ]] || ! enshrouded_editor_jq_ok "$config_file"; then
    ui_error "Invalid or missing config: $config_file"
    ui_pause
    return 1
  fi

  if ! menu_stop_server_for_config_change "edit Enshrouded settings"; then
    return 0
  fi

  menu_edit_json_from_spec \
    --title "Edit Enshrouded Settings" \
    --file "$config_file" \
    --metaField "enshroudedMenuJsonPath" \
    --labelMode "path" \
    --backupJob "manual:enshrouded" \
    --emptyAction "cancel" \
    --boolToggle "true" \
    --emptyLabel "<empty>" \
    --extra "__submenu_game_settings" "gameSettings (submenu)" "Game" "enshrouded_editor_game_settings_menu" \
    --extra "__submenu_user_groups" "userGroups (submenu)" "Access" "enshrouded_editor_user_groups_menu"
}

enshrouded_profile_actions_after_change() {
  echo
  ui_note "Apply changes:"
  ui_opt 1 "Start/restart Enshrouded server"
  ui_opt 2 "Run bootstrap (recommended; does not start server)"
  ui_opt 0 "Back to menu"
  echo
  case "$(ui_prompt_number "Action")" in
    1)
      supervisorctl restart server || true
      ui_success "Restart requested."
      ui_pause
      ;;
    2)
      supervisorctl start bootstrap || true
      ui_success "Bootstrap started."
      ui_note "Note: bootstrap does not start the server."
      if menu_wait_for_program_exit "bootstrap" 600; then
        echo
        menu_prompt_start_server "Start server now?"
      else
        ui_note "Start the server later once bootstrap has finished."
      fi
      ui_pause
      ;;
    0)
      ;;
    *)
      ;;
  esac
}

enshrouded_apply_profile_flow() {
  local config_file profiles profile_count idx selected profile
  config_file="$(enshrouded_config_path)"

  if ! menu_warn_env_overrides_before_enshrouded_profile_selection; then
    return 1
  fi

  mapfile -t profiles < <(profiles_list_enshrouded | sort)
  profile_count="${#profiles[@]}"
  if [[ "$profile_count" -eq 0 ]]; then
    ui_error "No Enshrouded profiles found in: $EN_PROFILE_DIR"
    ui_pause
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Select Enshrouded Profile"
    ui_kv "Profiles Folder" "$EN_PROFILE_DIR"
    echo
    idx=1
    for p in "${profiles[@]}"; do
      printf "%s[%s]%s %s%s%s\n" "${C_MAGENTA}" "$idx" "${C_RESET}" "${C_GREEN}" "$p" "${C_RESET}"
      idx=$((idx + 1))
    done
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    selected="$(ui_prompt_choice "Profile")"
    selected="$(echo "$selected" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$selected" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$selected" =~ ^[0-9]+$ ]] || [[ "$selected" -lt 1 || "$selected" -gt "$profile_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    profile="${profiles[$((selected - 1))]}"

    if checkRunning "server" || [[ -f "$config_file" ]]; then
      ui_warn_line "This will replace the active Enshrouded config with the selected profile."
      ui_warn_line "All players will be disconnected."
      echo
      ui_kv "Selected Profile" "$profile"
      ui_kv "Target File" "$config_file"
      echo
      if ! ui_confirm_yes_no "Stop server (if running) and apply this profile now?"; then
        ui_note "Cancelled."
        ui_pause
        continue
      fi
    fi

    if ! menu_write_request_json "profile.json" \
      --arg target "enshrouded" \
      --arg action "apply" \
      --arg profile "$profile" \
      '{target: $target, action: $action, profile: $profile}' >/dev/null; then
      ui_error "Failed to create request for profile."
      ui_pause
      continue
    fi

    supervisorctl start profile >/dev/null 2>&1 || true
    if ! menu_wait_for_program_exit "profile" 600; then
      ui_warn_line "Timeout while waiting for profile."
      ui_note "Check: supervisorctl status profile"
      ui_pause
      continue
    fi

    ui_success "Enshrouded profile applied: $profile"
    enshrouded_profile_actions_after_change
    return 0
  done
}

enshrouded_reset_profile_flow() {
  local profile config_file
  config_file="$(enshrouded_config_path)"
  profile="$(enshrouded_profile_resolve)"

  ui_header "Reset Enshrouded Profile"
  ui_warn_line "This resets enshrouded_server.json from the currently selected profile."
  ui_warn_line "All players will be disconnected."
  echo
  ui_kv "Profile" "$profile"
  ui_kv "Target File" "$config_file"
  echo

  if ! ui_confirm_yes_no "Stop server (if running) and reset now?"; then
    ui_note "Cancelled."
    ui_pause
    return 0
  fi

  if ! menu_write_request_json "profile.json" \
    --arg target "enshrouded" \
    --arg action "reset" \
    --arg profile "$profile" \
    '{target: $target, action: $action, profile: $profile}' >/dev/null; then
    ui_error "Failed to create request for profile reset."
    ui_pause
    return 1
  fi

  supervisorctl start profile >/dev/null 2>&1 || true
  if ! menu_wait_for_program_exit "profile" 600; then
    ui_warn_line "Timeout while waiting for profile."
    ui_note "Check: supervisorctl status profile"
    ui_pause
    return 1
  fi

  ui_success "Enshrouded profile reset completed: $profile"
  enshrouded_profile_actions_after_change
  return 0
}

menu_enshrouded_settings() {
  local choice
  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Enshrouded Server Settings"

    ui_opt 1 "Edit current settings"
    ui_opt 2 "Reset current profile"
    ui_opt 3 "Select and apply profile"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1) editor_enshrouded_json ;;
      2) enshrouded_reset_profile_flow || true ;;
      3) enshrouded_apply_profile_flow || true ;;
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        ;;
    esac
  done
}


# --- inlined menu module: manager ---
editor_manager_json() {
  local config_file backed_up
  config_file="$(manager_config_path)"
  backed_up="false"

  if [[ ! -f "$config_file" ]] || ! jq -e 'type == "object"' "$config_file" >/dev/null 2>&1; then
    ui_warn_line "server_manager.json is missing or invalid. Initializing..."
    update_or_create_manager_config || true
  fi

  if [[ ! -f "$config_file" ]]; then
    ui_error "Could not find server_manager.json: $config_file"
    ui_pause
    return 1
  fi

  if ! menu_stop_server_for_config_change "edit Server Manager settings"; then
    return 0
  fi

  menu_edit_json_from_spec \
    --title "Edit Server Manager Settings" \
    --file "$config_file" \
    --metaField "managerJsonPath" \
    --labelMode "var" \
    --backupJob "manual:manager" \
    --emptyAction "null" \
    --boolToggle "false" \
    --emptyLabel "<null>"
}

manager_profile_actions_after_change() {
  echo
  ui_note "Apply changes:"
  ui_opt 1 "Start/restart Enshrouded server"
  ui_opt 2 "Run bootstrap (recommended; updates cron, does not start server)"
  ui_opt 0 "Back to menu"
  echo

  case "$(ui_prompt_number "Action")" in
    1)
      supervisorctl restart server || true
      ui_success "Restart requested."
      ui_pause
      ;;
    2)
      supervisorctl start bootstrap || true
      ui_success "Bootstrap started."
      ui_note "Note: bootstrap does not start the server."
      if menu_wait_for_program_exit "bootstrap" 600; then
        echo
        menu_prompt_start_server "Start server now?"
      else
        ui_note "Start the server later once bootstrap has finished."
      fi
      ui_pause
      ;;
    0)
      ;;
    *)
      ;;
  esac
}

manager_apply_profile_flow() {
  local config_file profiles profile_count idx selected profile
  config_file="$(manager_config_path)"

  if ! menu_warn_env_overrides_before_manager_profile_selection; then
    return 1
  fi

  mapfile -t profiles < <(profiles_list_manager | sort)
  profile_count="${#profiles[@]}"
  if [[ "$profile_count" -eq 0 ]]; then
    ui_error "No Server Manager profiles found in: $MANAGER_PROFILE_TEMPLATE_DIR"
    ui_pause
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Select Server Manager Profile"
    ui_kv "Profiles Folder" "$MANAGER_PROFILE_TEMPLATE_DIR"
    echo
    idx=1
    for p in "${profiles[@]}"; do
      printf "%s[%s]%s %s%s%s\n" "${C_MAGENTA}" "$idx" "${C_RESET}" "${C_GREEN}" "$p" "${C_RESET}"
      idx=$((idx + 1))
    done
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    selected="$(ui_prompt_choice "Profile")"
    selected="$(echo "$selected" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$selected" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$selected" =~ ^[0-9]+$ ]] || [[ "$selected" -lt 1 || "$selected" -gt "$profile_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    profile="${profiles[$((selected - 1))]}"

    if checkRunning "server" || [[ -f "$config_file" ]]; then
      ui_warn_line "This will replace the active Server Manager config with the selected profile."
      ui_warn_line "All players will be disconnected."
      echo
      ui_kv "Selected Profile" "$profile"
      ui_kv "Target File" "$config_file"
      echo
      if ! ui_confirm_yes_no "Stop server (if running) and apply this profile now?"; then
        ui_note "Cancelled."
        ui_pause
        continue
      fi
    fi

    if ! menu_write_request_json "profile.json" \
      --arg target "manager" \
      --arg action "apply" \
      --arg profile "$profile" \
      '{target: $target, action: $action, profile: $profile}' >/dev/null; then
      ui_error "Failed to create request for profile."
      ui_pause
      continue
    fi

    supervisorctl start profile >/dev/null 2>&1 || true
    if ! menu_wait_for_program_exit "profile" 600; then
      ui_warn_line "Timeout while waiting for profile."
      ui_note "Check: supervisorctl status profile"
      ui_pause
      continue
    fi

    ui_success "Server Manager profile applied: $profile"
    manager_profile_actions_after_change
    return 0
  done
}

manager_reset_profile_flow() {
  local profile config_file
  config_file="$(manager_config_path)"
  profile="$(manager_profile_resolve)"

  ui_header "Reset Server Manager Profile"
  ui_warn_line "This resets server_manager.json from the currently selected profile."
  ui_warn_line "All players will be disconnected."
  echo
  ui_kv "Profile" "$profile"
  ui_kv "Target File" "$config_file"
  echo

  if ! ui_confirm_yes_no "Stop server (if running) and reset now?"; then
    ui_note "Cancelled."
    ui_pause
    return 0
  fi

  if ! menu_write_request_json "profile.json" \
    --arg target "manager" \
    --arg action "reset" \
    --arg profile "$profile" \
    '{target: $target, action: $action, profile: $profile}' >/dev/null; then
    ui_error "Failed to create request for profile reset."
    ui_pause
    return 1
  fi

  supervisorctl start profile >/dev/null 2>&1 || true
  if ! menu_wait_for_program_exit "profile" 600; then
    ui_warn_line "Timeout while waiting for profile."
    ui_note "Check: supervisorctl status profile"
    ui_pause
    return 1
  fi

  ui_success "Server Manager profile reset completed: $profile"
  manager_profile_actions_after_change
  return 0
}

menu_manager_settings() {
  local choice
  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Server Manager Settings"

    ui_opt 1 "Edit current settings"
    ui_opt 2 "Reset current profile"
    ui_opt 3 "Select and apply profile"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1) editor_manager_json ;;
      2) manager_reset_profile_flow || true ;;
      3) manager_apply_profile_flow || true ;;
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        ;;
    esac
  done
}


MENU_NAV=""
MENU_POST_HOOK_RAN="false"

run_menu_hook() {
  local hook_name hook_cmd
  hook_name="$1"
  hook_cmd="$2"
  if [[ -z "$hook_cmd" ]]; then
    return 0
  fi
  info "Running ${hook_name} hook: $hook_cmd"
  eval "$hook_cmd"
}

menu_run_post_hook_once() {
  if [[ "$MENU_POST_HOOK_RAN" == "true" ]]; then
    return 0
  fi
  MENU_POST_HOOK_RAN="true"
  run_menu_hook "menu post" "${MENU_POST_HOOK:-}"
}

menu_run_ctl() {
  local cmd
  cmd="$1"
  ui_hr
  ui_note "Running: ctl $cmd"
  echo
  # Use the canonical job path to avoid PATH issues.
  /usr/local/etc/enshrouded/jobs/ctl "$cmd" || true
  echo
  ui_pause
}

menu_default_items_main() {
  cat <<'EOF'
1|Enshrouded Server Settings|enshrouded-settings
2|Server Manager Settings|manager-settings
3|Backup Menu|backups
4|Start Server|ctl-start
5|Stop Server|ctl-stop
6|Restart Server|ctl-restart
7|Update Server|ctl-update
8|Force Update Server|ctl-force-update
9|View Passwords|ctl-password-view
10|Create Manual Backup (.zip)|backup-now
11|Other ctl Commands|other-commands
EOF
}

menu_default_items_other() {
  cat <<'EOF'
1|Status|ctl-status
2|Scheduled Restart|ctl-scheduled-restart
3|Bootstrap|ctl-bootstrap
4|Cron Start|ctl-cron-start
5|Cron Stop|ctl-cron-stop
6|Cron Restart|ctl-cron-restart
EOF
}

menu_items_from_spec() {
  local section
  section="$1"
  if [[ ! -f "$MENU_SPEC_FILE" ]] || ! command -v jq >/dev/null 2>&1; then
    return 1
  fi

  jq -r --arg section "$section" '
    (.menu[$section] // [])
    | map(select((.key // "") != "" and (.action // "") != ""))
    | .[]
    | "\(.key)|\((.title // .label // .action))|\(.action)"
  ' "$MENU_SPEC_FILE" 2>/dev/null
}

menu_items() {
  local section from_spec
  section="$1"
  from_spec="$(menu_items_from_spec "$section" 2>/dev/null || true)"
  if [[ -n "$from_spec" ]]; then
    printf "%s\n" "$from_spec"
    return 0
  fi

  case "$section" in
    main) menu_default_items_main ;;
    otherCommands) menu_default_items_other ;;
    *) return 1 ;;
  esac
}

menu_print_options() {
  local section key label action
  section="$1"
  while IFS='|' read -r key label action; do
    [[ -z "$key" || -z "$action" ]] && continue
    ui_opt "$key" "$label"
  done < <(menu_items "$section")
}

menu_action_for_choice() {
  local section choice key label action
  section="$1"
  choice="$2"
  while IFS='|' read -r key label action; do
    [[ -z "$key" || -z "$action" ]] && continue
    if [[ "$key" == "$choice" ]]; then
      printf "%s" "$action"
      return 0
    fi
  done < <(menu_items "$section")
  return 1
}

menu_dispatch_action() {
  local action
  action="$1"
  case "$action" in
    enshrouded-settings) menu_enshrouded_settings ;;
    manager-settings) menu_manager_settings ;;
    backups) menu_backups_menu ;;
    backup-now) menu_run_savegame_backup ;;
    other-commands) menu_other_commands ;;
    ctl-start) menu_run_ctl start ;;
    ctl-stop) menu_run_ctl stop ;;
    ctl-restart) menu_run_ctl restart ;;
    ctl-update) menu_run_ctl update ;;
    ctl-force-update) menu_run_ctl force-update ;;
    ctl-password-view) menu_run_ctl password-view ;;
    ctl-status) menu_run_ctl status ;;
    ctl-scheduled-restart) menu_run_ctl scheduled-restart ;;
    ctl-bootstrap) menu_run_ctl bootstrap ;;
    ctl-cron-start) menu_run_ctl cron-start ;;
    ctl-cron-stop) menu_run_ctl cron-stop ;;
    ctl-cron-restart) menu_run_ctl cron-restart ;;
    *)
      ui_warn_line "Unknown menu action: $action"
      ui_pause
      ;;
  esac
}

menu_other_commands() {
  local choice action
  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Other ctl Commands"
    menu_print_options "otherCommands"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if action="$(menu_action_for_choice "otherCommands" "$choice")"; then
      menu_dispatch_action "$action"
    else
      ui_warn_line "Invalid selection."
      ui_pause
    fi
  done
}

menu_main() {
  local choice action

  while :; do
    if menu_nav_is_set; then
      case "$(menu_nav_value)" in
        main) menu_nav_clear ;;
        *) return 0 ;;
      esac
    fi

    ui_header "Main Menu"
    menu_print_options "main"
    echo
    ui_actions_bar "x Exit"
    echo
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0|x|q)
        ui_clear
        menu_nav_set "exit"
        return 0
        ;;
    esac

    if action="$(menu_action_for_choice "main" "$choice")"; then
      menu_dispatch_action "$action"
    else
      ui_warn_line "Invalid selection."
      ui_pause
    fi
  done
}

trap menu_run_post_hook_once EXIT

run_menu_hook "menu pre" "${MENU_PRE_HOOK:-}"
menu_main

case "${MENU_NAV:-}" in
  exit)
    # On exit, offer to start the server if it is currently stopped.
    if ! checkRunning "server"; then
      ui_clear
      ui_banner
      ui_warn_line "The Enshrouded server is currently STOPPED."
      echo
      if ui_confirm_yes_no "Do you want me to start server before exiting?"; then
        ui_note "Starting server..."
        /usr/local/etc/enshrouded/jobs/ctl start >/dev/null 2>&1 || true
        ui_success "Start requested."
      else
        ui_note "Server remains stopped."
      fi
    fi
    ;;
esac

menu_run_post_hook_once


