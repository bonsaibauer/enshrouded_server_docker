#!/bin/bash
SCRIPT_DIR="$(cd -P "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" >/dev/null 2>&1 && pwd)"
# shellcheck source=server_manager/jobs/env-validation
. "${SCRIPT_DIR}/env-validation"

MENU_SPEC_TSV_FILE="${MENU_SPEC_TSV_FILE:-${SCRIPT_DIR}/../env/menu.tsv}"
MENU_SPEC_FILE="${MENU_SPEC_FILE:-}"
MENU_SPEC_TMP_FILE=""
MENU_START_SCREEN="main"
MENU_ONCE="false"
MENU_NO_CLEAR="false"

usage() {
  cat <<'EOF'
Usage:
  menu [--screen <id>] [--once] [--no-clear]
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --screen)
        MENU_START_SCREEN="${2-}"
        [[ -n "$MENU_START_SCREEN" ]] || fatal "Missing value for --screen"
        shift 2
        ;;
      --once)
        MENU_ONCE="true"
        shift
        ;;
      --no-clear)
        MENU_NO_CLEAR="true"
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        fatal "Unknown argument: $1"
        ;;
    esac
  done
}

menu_spec__append_action_row() {
  local json_file id type cmd fn requires_running confirm args_json
  local obj

  json_file="$1"
  id="$2"
  type="$3"
  cmd="$4"
  fn="$5"
  requires_running="$6"
  confirm="$7"
  args_json="$8"

  obj="$(jq -cn --arg type "$type" 'if $type == "" then {} else {type: $type} end')"
  [[ -n "$cmd" ]] && obj="$(jq -c --arg v "$cmd" '. + {cmd: $v}' <<<"$obj")"
  [[ -n "$fn" ]] && obj="$(jq -c --arg v "$fn" '. + {fn: $v}' <<<"$obj")"

  if [[ -n "$requires_running" ]]; then
    obj="$(jq -c --arg v "$requires_running" '. + {requiresRunning: (($v | ascii_downcase) == "true")}' <<<"$obj")"
  fi

  if [[ -n "$confirm" ]]; then
    case "$(echo "$confirm" | tr '[:upper:]' '[:lower:]')" in
      true|false)
        obj="$(jq -c --arg v "$confirm" '. + {confirm: (($v | ascii_downcase) == "true")}' <<<"$obj")"
        ;;
      *)
        obj="$(jq -c --arg v "$confirm" '. + {confirm: $v}' <<<"$obj")"
        ;;
    esac
  fi

  if [[ -n "$args_json" ]]; then
    obj="$(jq -c --arg args "$args_json" '. + {args: ($args | fromjson)}' <<<"$obj" 2>/dev/null || echo "$obj")"
  fi

  jq --arg id "$id" --argjson obj "$obj" '.actions[$id] = $obj' "$json_file" >"${json_file}.tmp" && mv "${json_file}.tmp" "$json_file"
}

menu_spec__append_screen_row() {
  local json_file screen key title action
  json_file="$1"
  screen="$2"
  key="$3"
  title="$4"
  action="$5"

  jq --arg screen "$screen" --arg key "$key" --arg title "$title" --arg action "$action" \
    '.screens[$screen] = ((.screens[$screen] // []) + [{key: $key, title: $title, action: $action}])' \
    "$json_file" >"${json_file}.tmp" && mv "${json_file}.tmp" "$json_file"
}

menu_spec__append_editor_env_row() {
  local json_file meta_field env_name group json_path order
  local obj
  json_file="$1"
  meta_field="$2"
  env_name="$3"
  group="$4"
  json_path="$5"
  order="$6"

  obj="$(jq -cn --arg env "$env_name" --arg group "$group" --arg json_path "$json_path" --arg order "$order" '
    {
      env: $env,
      group: $group
    }
    + (if $json_path == "" then {} else {jsonPath: $json_path} end)
    + (if $order == "" then {} else {order: ($order | tonumber)} end)
  ')"

  jq --arg mf "$meta_field" --argjson obj "$obj" '
    .editors[$mf] = (.editors[$mf] // {fields: []})
    | .editors[$mf].fields = ((.editors[$mf].fields // []) + [$obj])
  ' "$json_file" >"${json_file}.tmp" && mv "${json_file}.tmp" "$json_file"
}

menu_spec__append_editor_template_row() {
  local json_file template field group order
  local obj
  json_file="$1"
  template="$2"
  field="$3"
  group="$4"
  order="$5"

  obj="$(jq -cn --arg field "$field" --arg group "$group" --arg order "$order" '
    {
      field: $field,
      group: $group
    }
    + (if $order == "" then {} else {order: ($order | tonumber)} end)
  ')"

  jq --arg t "$template" --argjson obj "$obj" '
    .editors.templates = (.editors.templates // {})
    | .editors.templates[$t] = (.editors.templates[$t] // {fields: []})
    | .editors.templates[$t].fields = ((.editors.templates[$t].fields // []) + [$obj])
  ' "$json_file" >"${json_file}.tmp" && mv "${json_file}.tmp" "$json_file"
}

menu_spec_build_json_from_tsv() {
  local tsv_file out_file
  local section id parent key title action type cmd fn requires_running confirm _program _request_file _timeout_sec _payload_json args_json env_name group field json_path order

  tsv_file="$1"
  out_file="$2"

  jq -n '{actions: {}, screens: {}, editors: {templates: {}}}' >"$out_file" || return 1

  while IFS=$'\t' read -r section id parent key title action type cmd fn requires_running confirm _program _request_file _timeout_sec _payload_json args_json env_name group field json_path order; do
    [[ -z "$section" || "$section" == "section" ]] && continue
    case "$section" in
      action)
        [[ -z "$id" ]] && continue
        menu_spec__append_action_row "$out_file" "$id" "$type" "$cmd" "$fn" "$requires_running" "$confirm" "$args_json"
        ;;
      screen)
        [[ -z "$parent" || -z "$key" || -z "$action" ]] && continue
        menu_spec__append_screen_row "$out_file" "$parent" "$key" "$title" "$action"
        ;;
      editor_env)
        [[ -z "$parent" || -z "$env_name" ]] && continue
        menu_spec__append_editor_env_row "$out_file" "$parent" "$env_name" "$group" "$json_path" "$order"
        ;;
      editor_template)
        [[ -z "$parent" || -z "$field" ]] && continue
        menu_spec__append_editor_template_row "$out_file" "$parent" "$field" "$group" "$order"
        ;;
    esac
  done <"$tsv_file"
}

menu_spec_init() {
  if [[ -n "${MENU_SPEC_FILE:-}" && -f "$MENU_SPEC_FILE" ]]; then
    return 0
  fi
  if [[ ! -f "$MENU_SPEC_TSV_FILE" ]]; then
    return 1
  fi
  if ! command -v jq >/dev/null 2>&1; then
    return 1
  fi

  MENU_SPEC_TMP_FILE="$(mktemp)"
  if ! menu_spec_build_json_from_tsv "$MENU_SPEC_TSV_FILE" "$MENU_SPEC_TMP_FILE"; then
    rm -f "$MENU_SPEC_TMP_FILE" 2>/dev/null || true
    MENU_SPEC_TMP_FILE=""
    return 1
  fi
  MENU_SPEC_FILE="$MENU_SPEC_TMP_FILE"
  return 0
}


# --- inlined menu module: ui ---
# UI helpers for the interactive shell menu.
# Expected to be sourced after the menu runtime bootstrap so log helpers and colors exist.

ui_has_tty() {
  [[ -t 0 && -t 1 ]]
}

ui_clear() {
  if [[ "$MENU_NO_CLEAR" == "true" ]]; then
    return 0
  fi
  if command -v clear >/dev/null 2>&1; then
    clear
  else
    printf "\n\n\n\n\n\n\n"
  fi
}

ui_hr() {
  printf "%s\n" "--------------------------------------------------------------------------------"
}

ui_banner() {
  printf "%s" "${C_MAGENTA}"
  cat <<'EOF'
>>=============================================================<<
|| __  __    _    _   _    _    ____ _____ ____    _           ||
|||  \/  |  / \  | \ | |  / \  / ___| ____|  _ \  | |__  _   _ ||
||| |\/| | / _ \ |  \| | / _ \| |  _|  _| | |_) | | '_ \| | | |||
||| |  | |/ ___ \| |\  |/ ___ \ |_| | |___|  _ <  | |_) | |_| |||
|||_|  |_/_/   \_\_| \_/_/   \_\____|_____|_| \_\ |_.__/ \__, |||
||| |__   ___  _ __  ___  __ _(_) |__   __ _ _   _  ___ _|___/ ||
||| '_ \ / _ \| '_ \/ __|/ _` | | '_ \ / _` | | | |/ _ \ '__|  ||
||| |_) | (_) | | | \__ \ (_| | | |_) | (_| | |_| |  __/ |     ||
|||_.__/ \___/|_| |_|___/\__,_|_|_.__/ \__,_|\__,_|\___|_|     ||
>>=============================================================<<
EOF
  printf "%s" "${C_RESET}"
  printf "%s\n" "${C_GREEN}                 Server Manager${C_RESET}"
  printf "%s\n" "${C_DIM}        Enshrouded Control Layer${C_RESET}"
  ui_hr
}

ui_kv() {
  local k v
  k="$1"
  v="$2"
  printf "%s: %s\n" "${C_DIM}${k}${C_RESET}" "$v"
}

ui_note() {
  printf "%s%s%s\n" "${C_DIM}" "$*" "${C_RESET}"
}

ui_error() {
  printf "%s%s%s\n" "${C_RED}" "$*" "${C_RESET}" >&2
}

ui_warn_line() {
  printf "%s%s%s\n" "${C_YELLOW}" "$*" "${C_RESET}"
}

ui_success() {
  printf "%s%s%s\n" "${C_GREEN}" "$*" "${C_RESET}"
}

ui_opt() {
  # Print a menu option with a colored key.
  # Usage: ui_opt 1 "Edit current settings"
  local key text
  key="$1"
  shift || true
  text="$*"
  printf "%s[%s]%s %s\n" "${C_MAGENTA}" "$key" "${C_RESET}" "$text"
}

ui_read() {
  local prompt value
  prompt="$1"
  if [[ -r /dev/tty ]]; then
    read -r -p "$prompt" value </dev/tty || true
  else
    read -r -p "$prompt" value || true
  fi
  printf "%s" "$value"
}

ui_pause() {
  local _unused
  if [[ -r /dev/tty ]]; then
    read -r -p "Press Enter to continue..." _unused </dev/tty || true
  else
    read -r -p "Press Enter to continue..." _unused || true
  fi
}

ui_confirm_yes_no() {
  local prompt ans normalized
  prompt="$1"
  while :; do
    ans="$(ui_read "$prompt [yes/no]: ")"
    normalized="$(echo "$ans" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$normalized" in
      y|yes|j|ja)
        return 0
        ;;
      n|no|nein|"")
        return 1
        ;;
      *)
        ui_warn_line "Please answer yes or no."
        ;;
    esac
  done
}

ui_prompt_number() {
  local prompt ans
  prompt="$1"
  while :; do
    ans="$(ui_read "$prompt: ")"
    ans="$(echo "$ans" | xargs)"
    if [[ "$ans" =~ ^[0-9]+$ ]]; then
      printf "%s" "$ans"
      return 0
    fi
    ui_warn_line "Please enter a number."
  done
}

ui_prompt_choice() {
  # Reads a raw choice (number or letter command) from the user.
  local prompt ans
  prompt="$1"
  ans="$(ui_read "$prompt: ")"
  ans="$(echo "$ans" | xargs)"
  printf "%s" "$ans"
}

ui_actions_bar() {
  # Nano-like action hint bar (simple, line-based).
  # Usage: ui_actions_bar "0 Back" "m Main" "x Exit"
  local item
  ui_hr
  printf "%s" "${C_MAGENTA}"
  printf "%s" "Actions:"
  for item in "$@"; do
    printf "  [%s]" "$item"
  done
  printf "%s\n" "${C_RESET}"
}

menu_nav_clear() { MENU_NAV=""; }
menu_nav_set() { MENU_NAV="$1"; }
menu_nav_is_set() { [[ -n "${MENU_NAV:-}" ]]; }
menu_nav_value() { printf "%s" "${MENU_NAV:-}"; }

menu_mountinfo_decode_path() {
  # /proc/self/mountinfo uses octal escapes for spaces, tabs, etc (e.g. \040).
  # Decode for display only.
  local raw
  raw="$1"
  printf "%b" "$raw"
}

menu_container_to_host_path() {
  # Best-effort conversion of a container path to the bind-mount source path as seen by the host.
  #
  # For bind mounts, /proc/self/mountinfo typically exposes the host path in the "root" field.
  # For named volumes, the root may point into Docker's data directory.
  local container_path line root_raw mp_raw root mp best_mp best_root rel
  container_path="$1"

  if [[ ! -r /proc/self/mountinfo ]]; then
    return 1
  fi

  best_mp=""
  best_root=""
  while IFS= read -r line; do
    # root and mount point are the 4th and 5th whitespace-separated fields.
    set -- $line
    root_raw="${4-}"
    mp_raw="${5-}"
    if [[ -z "$root_raw" || -z "$mp_raw" ]]; then
      continue
    fi

    root="$(menu_mountinfo_decode_path "$root_raw")"
    mp="$(menu_mountinfo_decode_path "$mp_raw")"

    if [[ "$container_path" == "$mp" || "$container_path" == "$mp/"* ]]; then
      if [[ ${#mp} -gt ${#best_mp} ]]; then
        best_mp="$mp"
        best_root="$root"
      fi
    fi
  done </proc/self/mountinfo

  # Avoid mapping to the container root filesystem (usually overlay).
  if [[ -z "$best_mp" || "$best_mp" == "/" || -z "$best_root" ]]; then
    return 1
  fi

  rel="${container_path#$best_mp}"
  if [[ -n "$rel" && "${rel:0:1}" != "/" ]]; then
    rel="/$rel"
  fi

  printf "%s%s" "${best_root%/}" "$rel"
  return 0
}

menu_display_path() {
  # Best-effort display of host path instead of container path.
  # Priority:
  # 1) HOST_INSTALL_PATH (explicit override)
  # 2) /proc/self/mountinfo mapping (bind mounts)
  local container_path host_path
  container_path="$1"

  if [[ -n "${HOST_INSTALL_PATH:-}" ]] && [[ "$container_path" == "$install_path"* ]]; then
    printf "%s%s" "${HOST_INSTALL_PATH%/}" "${container_path#$install_path}"
    return 0
  fi

  if host_path="$(menu_container_to_host_path "$container_path" 2>/dev/null)"; then
    if [[ -n "$host_path" ]]; then
      printf "%s" "$host_path"
      return 0
    fi
  fi

  printf "%s" "$container_path"
}

ui_header() {
  local subtitle
  subtitle="${1:-}"

  ui_clear
  ui_banner
  if [[ -n "$subtitle" ]]; then
    printf "\n%s%s%s\n" "${C_DIM}" "$subtitle" "${C_RESET}"
  fi

  # Status block (non-fatal if supervisorctl fails)
  local en_profile manager_profile server_status
  en_profile="$(enshrouded_profile_resolve 2>/dev/null || echo "default")"
  manager_profile="$(manager_profile_resolve 2>/dev/null || echo "default")"

  if checkRunning "server"; then
    server_status="${C_GREEN}RUNNING${C_RESET}"
  else
    server_status="${C_RED}STOPPED${C_RESET}"
  fi

  ui_kv "Enshrouded Profile" "${C_GREEN}${en_profile}${C_RESET}"
  ui_kv "Manager Profile" "${C_GREEN}${manager_profile}${C_RESET}"
  ui_kv "Server" "$server_status"
  ui_kv "Enshrouded Config" "$(menu_display_path "${install_path}/enshrouded_server.json")"
  ui_kv "Manager Config" "$(menu_display_path "$(manager_config_path)")"
  ui_hr

  if ui_has_tty; then
    ui_note "Navigation: enter a number (or command letter) and press Enter."
    ui_note "Exit behavior: if the server is STOPPED, you will be asked if it should be started."
  else
    ui_warn_line "Hint: no TTY detected. Start with: docker exec -it CONTAINER_NAME cmd menu"
  fi
  echo
}

menu_stop_server_now() {
  # Stop the Enshrouded server without asking (callers must confirm before invoking).
  if ! checkRunning "server"; then
    return 0
  fi

  /usr/local/etc/enshrouded/jobs/cmd stop >/dev/null 2>&1 || true

  # Best-effort wait until supervisor reports it stopped.
  local deadline now
  deadline=$(( $(date +%s) + 30 ))
  while checkRunning "server"; do
    now="$(date +%s)"
    if [[ "$now" -ge "$deadline" ]]; then
      ui_error "Timeout while stopping server. Aborting."
      return 1
    fi
    sleep 1
  done

  return 0
}

menu_stop_server_for_config_change() {
  local reason
  reason="$1"

  if ! checkRunning "server"; then
    return 0
  fi

  ui_warn_line "The Enshrouded server is currently RUNNING."
  ui_warn_line "To $reason, the server must be stopped first to avoid conflicts."
  ui_warn_line "All players will be disconnected."
  echo

  if ! ui_confirm_yes_no "Stop server now?"; then
    ui_note "Cancelled."
    return 1
  fi

  if ! menu_stop_server_now; then
    return 1
  fi

  ui_success "server stopped."
  return 0
}

menu_prompt_start_server() {
  local prompt
  prompt="${1:-Start server now?}"

  if ui_confirm_yes_no "$prompt"; then
    /usr/local/etc/enshrouded/jobs/cmd start >/dev/null 2>&1 || true
    ui_success "Server start requested."
  else
    ui_note "Server remains stopped."
  fi
}

menu_wait_for_program_exit() {
  local proc timeout deadline now
  proc="$1"
  timeout="${2:-600}"

  if ! checkRunning "$proc"; then
    return 0
  fi

  ui_note "Waiting for $proc to finish..."
  deadline=$(( $(date +%s) + timeout ))
  while checkRunning "$proc"; do
    now="$(date +%s)"
    if [[ "$now" -ge "$deadline" ]]; then
      ui_warn_line "Timeout while waiting for $proc."
      return 1
    fi
    sleep 1
  done

  return 0
}

menu_env_override_is_set() {
  local name
  name="$1"
  [[ -n "${MENU_EXTERNAL_ENV[$name]+x}" ]]
}

menu_env_override_value() {
  local name
  name="$1"
  printf "%s" "${MENU_EXTERNAL_ENV[$name]-}"
}

menu_env_override_pretty_value() {
  local name value max
  name="$1"
  value="$2"
  max=80

  if [[ "$name" == *_HOOK || "$name" == *HOOK* ]]; then
    if [[ -n "$value" ]]; then
      printf "%s" "<set>"
    fi
    return 0
  fi

  if [[ "${#value}" -gt "$max" ]]; then
    printf "%s..." "${value:0:$max}"
  else
    printf "%s" "$value"
  fi
}

menu_env_locked_badge() {
  local env_var
  env_var="$1"
  if menu_env_override_is_set "$env_var"; then
    printf " %s" "${C_RED}[ENV]${C_RESET}"
  fi
}

menu_warn_env_overrides_before_profile_selection() {
  local target label k value
  local -a keys active
  target="$1"
  keys=()
  active=()

  case "$target" in
    manager)
      label="Server Manager"
      mapfile -t keys < <(validation_list_envs_by_meta_field "managerJsonPath")
      ;;
    enshrouded)
      label="Enshrouded"
      for k in "${!MENU_EXTERNAL_ENV[@]}"; do
        case "$k" in
          ENSHROUDED_*) keys+=("$k") ;;
        esac
      done
      ;;
    *)
      return 1
      ;;
  esac

  for k in "${keys[@]}"; do
    [[ -z "$k" ]] && continue
    if menu_env_override_is_set "$k"; then
      active+=("$k")
    fi
  done

  if [[ "${#active[@]}" -eq 0 ]]; then
    return 0
  fi

  mapfile -t active < <(printf "%s\n" "${active[@]}" | sort)

  ui_header "Environment Overrides Detected"
  ui_warn_line "Some ${label} settings are controlled by environment variables."
  ui_warn_line "They will overwrite profile/template values on bootstrap or next container start."
  echo
  ui_note "Active overrides:"
  for k in "${active[@]}"; do
    value="$(menu_env_override_value "$k")"
    printf "%s=%s\n" "$k" "$(menu_env_override_pretty_value "$k" "$value")"
  done
  echo

  if ! ui_confirm_yes_no "Continue anyway?"; then
    ui_note "Cancelled."
    ui_pause
    return 1
  fi

  return 0
}

menu_run_backup_job() {
  # Trigger unified backup job via args.
  # Usage:
  #   menu_run_backup_job <mode> <includeSavegame> <includeEnshroudedConfig> <includeManagerConfig> [cleanup]
  local mode include_savegame include_ens include_mgr cleanup
  local -a cmd_args
  mode="${1:-manual}"
  include_savegame="${2:-true}"
  include_ens="${3:-true}"
  include_mgr="${4:-true}"
  cleanup="${5:-false}"

  cmd_args=(backup --mode "$mode")
  if [[ "$include_savegame" == "true" ]]; then cmd_args+=(--with-savegame); else cmd_args+=(--without-savegame); fi
  if [[ "$include_ens" == "true" ]]; then cmd_args+=(--with-enshrouded-config); else cmd_args+=(--without-enshrouded-config); fi
  if [[ "$include_mgr" == "true" ]]; then cmd_args+=(--with-manager-config); else cmd_args+=(--without-manager-config); fi
  if [[ "$cleanup" == "true" ]]; then cmd_args+=(--cleanup); else cmd_args+=(--no-cleanup); fi

  if ! /usr/local/etc/enshrouded/jobs/cmd "${cmd_args[@]}" >/dev/null 2>&1; then
    ui_error "Backup command failed."
    return 1
  fi

  return 0
}

menu_run_config_backup_job() {
  # Selector wrapper used by editors for config-only backups.
  # Config-only backups are written under BACKUP_DIR/manual (without savegame files).
  local selector include_ens include_mgr
  selector="${1:-manual:all}"
  include_ens="true"
  include_mgr="true"

  case "$selector" in
    manual:enshrouded|enshrouded)
      include_ens="true"
      include_mgr="false"
      ;;
    manual:manager|manager)
      include_ens="false"
      include_mgr="true"
      ;;
    manual:all|all)
      include_ens="true"
      include_mgr="true"
      ;;
    *)
      ui_warn_line "Unknown config backup selector: $selector"
      return 1
      ;;
  esac

  menu_run_backup_job "manual" "false" "$include_ens" "$include_mgr" "false"
}


# --- inlined menu module: backups ---
menu_save_dir_resolve() {
  local dir
  dir="${ENSHROUDED_SAVE_DIR:-./savegame}"
  if [[ "$dir" == /* ]]; then
    printf "%s" "$dir"
  else
    printf "%s/%s" "$install_path" "$dir"
  fi
}

menu_backup_kind_from_path() {
  local backup_root rel
  backup_root="$(backup_dir_resolve)"
  rel="${1#$backup_root/}"
  case "$rel" in
    scheduled/*) echo "scheduled" ;;
    manual/*) echo "manual" ;;
    *) echo "manual" ;;
  esac
}

menu_backup_list_files() {
  local backup_root
  backup_root="$(backup_dir_resolve)"

  {
    find "${backup_root}/manual" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
    find "${backup_root}/scheduled" -maxdepth 1 -type f -name "*.zip" -printf '%T@\t%p\n' 2>/dev/null || true
  } | sort -rn | cut -f2-
}

menu_backup_zip_entries() {
  local zip_file
  zip_file="$1"

  python3 - "$zip_file" <<'PY'
import pathlib
import sys
import zipfile

zip_path = pathlib.Path(sys.argv[1])
try:
    with zipfile.ZipFile(zip_path, "r") as zf:
        for name in zf.namelist():
            print(name)
except Exception:
    pass
PY
}

menu_backup_detect_components() {
  local zip_file entries has_savegame has_enshrouded has_manager
  zip_file="$1"
  entries="$(menu_backup_zip_entries "$zip_file")"
  has_savegame="false"
  has_enshrouded="false"
  has_manager="false"

  if printf '%s\n' "$entries" | grep -q '^savegame/'; then
    has_savegame="true"
  fi

  if printf '%s\n' "$entries" | grep -Fxq "config/enshrouded_server.json"; then
    has_enshrouded="true"
  fi

  if printf '%s\n' "$entries" | grep -Fxq "config/server_manager.json"; then
    has_manager="true"
  fi

  printf "%s %s %s" "$has_savegame" "$has_enshrouded" "$has_manager"
}

menu_run_savegame_backup() {
  local backup_dir save_dir
  backup_dir="$(backup_dir_resolve)"
  save_dir="$(menu_save_dir_resolve)"

  ui_header "Create Manual Backup"
  ui_note "Manual backups are stored under BACKUP_DIR/manual and are never pruned by backupMaxCount."
  echo
  ui_kv "Save Directory" "$save_dir"
  ui_kv "Backup Root" "$backup_dir"
  ui_kv "Target Folder" "${backup_dir}/manual"
  echo

  if ! ui_confirm_yes_no "Create manual full backup now?"; then
    ui_note "Cancelled."
    ui_pause
    return 0
  fi

  if menu_run_backup_job "manual" "true" "true" "true" "false"; then
    ui_success "Manual backup created."
  else
    ui_warn_line "Backup failed or timed out."
  fi

  ui_pause
  return 0
}

menu_run_config_backup_now() {
  local choice include_ens include_mgr
  include_ens="true"
  include_mgr="true"

  while :; do
    ui_header "Create Config Backup"
    ui_note "Creates a config-only ZIP under BACKUP_DIR/manual."
    echo
    ui_opt 1 "Enshrouded config only"
    ui_opt 2 "Server Manager config only"
    ui_opt 3 "Both config files"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1)
        include_ens="true"
        include_mgr="false"
        ;;
      2)
        include_ens="false"
        include_mgr="true"
        ;;
      3)
        include_ens="true"
        include_mgr="true"
        ;;
      0)
        return 0
        ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        continue
        ;;
    esac

    if menu_run_backup_job "manual" "false" "$include_ens" "$include_mgr" "false"; then
      ui_success "Config backup created."
    else
      ui_warn_line "Config backup failed or timed out."
    fi
    ui_pause
    return 0
  done
}

menu_restore_backup() {
  local backup_root save_dir selected choice file
  backup_root="$(backup_dir_resolve)"
  save_dir="$(menu_save_dir_resolve)"

  while :; do
    local -a files
    mapfile -t files < <(menu_backup_list_files)

    ui_header "Restore Backup"
    ui_kv "Backup Root" "$backup_root"
    ui_kv "Target Save Directory" "$save_dir"
    ui_kv "Savefile Name" "$savefile_name"
    echo

    if [[ "${#files[@]}" -eq 0 ]]; then
      ui_warn_line "No backup ZIP files found."
      echo
      if ui_confirm_yes_no "Create a manual backup now?"; then
        menu_run_savegame_backup || true
        continue
      fi
      return 0
    fi

    ui_note "Backups (newest first):"
    echo
    local idx base kind
    idx=1
    for file in "${files[@]}"; do
      base="$(basename "$file")"
      kind="$(menu_backup_kind_from_path "$file")"
      printf "%s[%s]%s %-11s %s\n" "${C_MAGENTA}" "$idx" "${C_RESET}" "${kind}" "$base"
      idx=$((idx + 1))
    done
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Backup")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0)
        return 0
        ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "${#files[@]}" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    selected="${files[$((choice - 1))]}"

    local has_savegame has_enshrouded has_manager
    read -r has_savegame has_enshrouded has_manager <<<"$(menu_backup_detect_components "$selected")"
    if [[ "$has_savegame" != "true" && "$has_enshrouded" != "true" && "$has_manager" != "true" ]]; then
      ui_warn_line "No restorable components detected in this backup."
      ui_pause
      continue
    fi

    ui_header "Restore Backup"
    ui_warn_line "WARNING: Selected components will overwrite current data."
    ui_warn_line "The server will be stopped and players disconnected."
    echo
    ui_kv "Selected Backup" "$(basename "$selected")"
    ui_kv "Detected Components" "savegame=$has_savegame, enshrouded=$has_enshrouded, manager=$has_manager"
    echo

    if ! ui_confirm_yes_no "Continue to component selection?"; then
      ui_note "Cancelled."
      ui_pause
      continue
    fi

    local restore_savegame restore_enshrouded restore_manager safety
    restore_savegame="false"
    restore_enshrouded="false"
    restore_manager="false"
    safety="false"

    if [[ "$has_savegame" == "true" ]] && ui_confirm_yes_no "Restore savegame files?"; then
      restore_savegame="true"
    fi
    if [[ "$has_enshrouded" == "true" ]] && ui_confirm_yes_no "Restore enshrouded_server.json?"; then
      restore_enshrouded="true"
    fi
    if [[ "$has_manager" == "true" ]] && ui_confirm_yes_no "Restore server_manager.json?"; then
      restore_manager="true"
    fi

    if [[ "$restore_savegame" != "true" && "$restore_enshrouded" != "true" && "$restore_manager" != "true" ]]; then
      ui_warn_line "Nothing selected for restore."
      ui_pause
      continue
    fi

    if ui_confirm_yes_no "Create safety backup before restore?"; then
      safety="true"
    fi

    local restore_selector
    local -a restore_parts restore_cmd
    restore_parts=()
    [[ "$restore_savegame" == "true" ]] && restore_parts+=("savegame")
    [[ "$restore_enshrouded" == "true" ]] && restore_parts+=("enshrouded")
    [[ "$restore_manager" == "true" ]] && restore_parts+=("manager")
    restore_selector="$(IFS=,; echo "${restore_parts[*]}")"

    restore_cmd=(restore-backup --zip "$selected" --restore "$restore_selector")
    if [[ "$safety" == "true" ]]; then
      restore_cmd+=(--safety-backup)
    else
      restore_cmd+=(--no-safety-backup)
    fi

    if ! /usr/local/etc/enshrouded/jobs/cmd "${restore_cmd[@]}" >/dev/null 2>&1; then
      ui_error "Restore command failed."
      ui_pause
      continue
    fi

    ui_success "Restore finished."
    echo
    menu_prompt_start_server "Start server now?"
    ui_pause
    return 0
  done
}

menu_backups_menu() {
  local choice
  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Backups"

    ui_opt 1 "Restore from backup ZIP"
    ui_opt 2 "Create manual full backup now"
    ui_opt 3 "Create config backup now"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1) menu_restore_backup || true ;;
      2) menu_run_savegame_backup || true ;;
      3) menu_run_config_backup_now || true ;;
      0) return 0 ;;
      m)
        menu_nav_set "main"
        return 0
        ;;
      x|q)
        menu_nav_set "exit"
        return 0
        ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        ;;
    esac
  done
}


menu_editor_envs_for_meta_field() {
  local meta_field vars
  meta_field="$1"

  [[ -f "$MENU_SPEC_FILE" ]] || return 0
  command -v jq >/dev/null 2>&1 || return 0

  vars="$(jq -r --arg key "$meta_field" '
    (.editors[$key].fields // [])
    | map(select((.env // "") != ""))
    | .[].env
  ' "$MENU_SPEC_FILE" 2>/dev/null || true)"

  [[ -n "$vars" ]] && printf "%s\n" "$vars"
}

menu_editor_group_for_env() {
  local meta_field env_var group
  meta_field="$1"
  env_var="$2"

  [[ -f "$MENU_SPEC_FILE" ]] || return 0
  command -v jq >/dev/null 2>&1 || return 0

  group="$(jq -r --arg key "$meta_field" --arg env "$env_var" '
    first((.editors[$key].fields // [])[] | select((.env // "") == $env) | (.group // empty)) // empty
  ' "$MENU_SPEC_FILE" 2>/dev/null || true)"

  [[ -n "$group" && "$group" != "null" ]] && printf "%s" "$group"
}

menu_editor_template_fields() {
  local template fields
  template="$1"

  [[ -f "$MENU_SPEC_FILE" ]] || return 0
  command -v jq >/dev/null 2>&1 || return 0

  fields="$(jq -r --arg t "$template" '
    (.editors.templates[$t].fields // [])
    | map(select((.field // "") != ""))
    | .[].field
  ' "$MENU_SPEC_FILE" 2>/dev/null || true)"

  [[ -n "$fields" ]] && printf "%s\n" "$fields"
}

menu_editor_template_group_for_field() {
  local template field group
  template="$1"
  field="$2"

  [[ -f "$MENU_SPEC_FILE" ]] || return 0
  command -v jq >/dev/null 2>&1 || return 0

  group="$(jq -r --arg t "$template" --arg field "$field" '
    first((.editors.templates[$t].fields // [])[] | select((.field // "") == $field) | (.group // empty)) // empty
  ' "$MENU_SPEC_FILE" 2>/dev/null || true)"

  [[ -n "$group" && "$group" != "null" ]] && printf "%s" "$group"
}


# --- inlined menu module: editor_spec_json ---
# Generic, spec-driven JSON editor helpers for the interactive menu.
# Validation/type hints come from `server_manager/env/env_server_manager.tsv`
# and `server_manager/env/env_enshrouded_server.tsv`.
# Menu actions/order/grouping/path mappings come from `server_manager/env/menu.tsv`.

menu_spec_editor__json_get_scalar() {
  # Prints the scalar as a string, but keeps `false` and `0` visible.
  local file path
  file="$1"
  path="$2"
  jq -r "$path | if . == null then empty else tostring end" "$file" 2>/dev/null || echo ""
}

menu_spec_editor__json_get_csv_list() {
  # Prints a CSV representation of a JSON array (used for list env values).
  local file path
  file="$1"
  path="$2"
  jq -r "$path // [] | if type == \"array\" then join(\",\") else empty end" "$file" 2>/dev/null || echo ""
}

menu_spec_editor__session_backup_if_needed() {
  # Create exactly one config backup per edit session (first write wins).
  # Uses dynamic scope: the calling editor sets `backed_up=false` locally.
  local backup_job
  backup_job="${1-}"

  if [[ -z "$backup_job" ]]; then
    return 0
  fi
  if [[ "${backed_up:-false}" == "true" ]]; then
    return 0
  fi
  ui_note "Creating config backup (logged via Supervisor)..."
  menu_run_config_backup_job "$backup_job" || true
  backed_up="true"
  return 0
}

menu_spec_editor__set_jq() {
  # Apply a jq transform to $file atomically.
  local file tmp
  file="$1"
  shift

  tmp="$(mktemp)"
  if jq "$@" "$file" >"$tmp"; then
    mv "$tmp" "$file"
    chmod 600 "$file" 2>/dev/null || true
    chown enshrouded:enshrouded "$file" 2>/dev/null || true
    return 0
  fi
  rm -f "$tmp" 2>/dev/null || true
  return 1
}

menu_spec_editor__block_if_env_locked() {
  # Returns 0 if editable, 1 if locked by external env override.
  local env_var env_value
  env_var="$1"

  if ! menu_env_override_is_set "$env_var"; then
    return 0
  fi

  env_value="$(menu_env_override_value "$env_var")"
  ui_warn_line "This setting is controlled by an environment variable and cannot be edited here."
  ui_kv "ENV" "$env_var=$(menu_env_override_pretty_value "$env_var" "$env_value")"
  ui_note "Remove it from your docker-compose/container environment to edit this value."
  ui_pause
  return 1
}

menu_spec_editor__display_value_for_var() {
  local file env_var json_path empty_label rule
  file="$1"
  env_var="$2"
  json_path="$3"
  empty_label="${4:-<empty>}"

  if menu_env_override_is_set "$env_var"; then
    local raw
    raw="$(menu_env_override_value "$env_var")"
    if [[ -z "$raw" ]]; then
      printf "%s" "${C_DIM}${empty_label}${C_RESET}"
    else
      printf "%s%s%s" "${C_RED}" "$raw" "${C_RESET}"
    fi
    return 0
  fi

  rule="$(validation_rule_json "$env_var" 2>/dev/null || true)"
  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    local csv
    csv="$(menu_spec_editor__json_get_csv_list "$file" "$json_path")"
    if [[ -z "$csv" ]]; then
      printf "%s" "${C_DIM}${empty_label}${C_RESET}"
    else
      printf "%s%s%s" "${C_GREEN}" "$csv" "${C_RESET}"
    fi
    return 0
  fi

  local raw
  raw="$(menu_spec_editor__json_get_scalar "$file" "$json_path")"
  if [[ -z "$raw" ]]; then
    printf "%s" "${C_DIM}${empty_label}${C_RESET}"
  else
    printf "%s%s%s" "${C_GREEN}" "$raw" "${C_RESET}"
  fi
}

menu_spec_editor__prompt_value() {
  # Prompts for a new value. Prints the raw input to stdout.
  local env_var label current empty_action bool_toggle
  env_var="$1"
  label="$2"
  current="$3"
  empty_action="${4:-cancel}"   # cancel|null|clear_list
  bool_toggle="${5:-false}"

  local type desc hint required allow_empty
  type="$(validation_env_type "$env_var" 2>/dev/null || true)"
  [[ -z "$type" ]] && type="string"

  echo
  ui_kv "Field" "$label"
  ui_kv "Current" "${current:-<empty>}"
  desc="$(validation_env_description "$env_var" 2>/dev/null || true)"
  hint="$(validation_env_allowed_hint "$env_var" 2>/dev/null || true)"
  [[ -n "$desc" ]] && ui_note "$desc"
  [[ -n "$hint" ]] && ui_note "$hint"

  required="$(validation_env_required "$env_var" 2>/dev/null || true)"
  allow_empty="$(validation_env_allow_empty "$env_var" 2>/dev/null || echo "true")"
  if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
    ui_note "Enter = toggle"
  else
    if [[ "$required" == "true" ]]; then
      ui_note "Empty is not allowed"
    else
      case "$empty_action" in
        null)
          if [[ "$allow_empty" == "true" ]]; then
            ui_note "Empty = null"
          else
            ui_note "Empty is not allowed"
          fi
          ;;
        clear_list)
          if [[ "$allow_empty" == "true" ]]; then
            ui_note "Empty = clear"
          else
            ui_note "Empty is not allowed"
          fi
          ;;
        *)
          ui_note "Empty = cancel"
          ;;
      esac
    fi
  fi
  echo

  local value normalized
  value="$(ui_read "New value: ")"
  value="$(echo "$value" | xargs)"

  # Normalize booleans for convenience.
  if [[ "$type" == "bool" ]]; then
    normalized="$(echo "$value" | tr '[:upper:]' '[:lower:]')"
    case "$normalized" in
      1|ja|j|y|yes) value="true" ;;
      0|nein|n|no) value="false" ;;
      true|false) value="$normalized" ;;
    esac
  fi

  printf "%s" "$value"
}

menu_spec_editor__edit_var() {
  # Edit a single variable using validation rules and either meta mapping or explicit JSON path.
  local file meta_field env_var json_path label empty_action backup_job bool_toggle explicit_json_path
  file="$1"
  meta_field="$2"
  env_var="$3"
  label="$4"
  empty_action="${5:-cancel}"
  backup_job="${6-}"
  bool_toggle="${7:-false}"
  explicit_json_path="${8-}"

  if ! menu_spec_editor__block_if_env_locked "$env_var"; then
    return 0
  fi

  if [[ -n "$explicit_json_path" ]]; then
    json_path="$explicit_json_path"
  else
    json_path="$(validation_env_meta_field "$env_var" "$meta_field" 2>/dev/null || true)"
  fi
  if [[ -z "$json_path" ]]; then
    ui_warn_line "No config mapping for: $env_var"
    ui_pause
    return 0
  fi

  local rule type current v
  rule="$(validation_rule_json "$env_var" 2>/dev/null || true)"
  type="$(validation_env_type "$env_var" 2>/dev/null || echo "string")"
  [[ -z "$type" ]] && type="string"

  if jq -e '(.list|type) == "object"' <<<"$rule" >/dev/null 2>&1; then
    current="$(menu_spec_editor__json_get_csv_list "$file" "$json_path")"
    v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "clear_list" "false")"
    if [[ -z "$v" ]]; then
      if ! validation_check "$env_var" ""; then
        ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
        ui_pause
        return 0
      fi
      menu_spec_editor__session_backup_if_needed "$backup_job" || true
      menu_spec_editor__set_jq "$file" "$json_path = []" || true
      return 0
    fi
    if ! validation_check "$env_var" "$v"; then
      ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
      ui_pause
      return 0
    fi
    menu_spec_editor__session_backup_if_needed "$backup_job" || true
    menu_spec_editor__set_jq "$file" --arg val "$v" "$json_path = (\$val | split(\",\") | map(gsub(\"^\\\\s+|\\\\s+$\";\"\")) | map(select(length>0)))" || true
    return 0
  fi

  current="$(menu_spec_editor__json_get_scalar "$file" "$json_path")"

  if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
    [[ -z "$current" ]] && current="false"
  fi

  v="$(menu_spec_editor__prompt_value "$env_var" "$label" "$current" "$empty_action" "$bool_toggle")"
  if [[ -z "$v" ]]; then
    if [[ "$type" == "bool" && "$bool_toggle" == "true" ]]; then
      if [[ "$current" == "true" ]]; then
        v="false"
      else
        v="true"
      fi
    else
      if [[ "$empty_action" == "null" ]]; then
        if ! validation_check "$env_var" ""; then
          ui_warn_line "${VALIDATION_LAST_ERROR:-Empty is not allowed}"
          ui_pause
          return 0
        fi
        menu_spec_editor__session_backup_if_needed "$backup_job" || true
        menu_spec_editor__set_jq "$file" "$json_path = null" || true
      fi
      return 0
    fi
  fi

  if ! validation_check "$env_var" "$v"; then
    ui_warn_line "${VALIDATION_LAST_ERROR:-Invalid value}"
    ui_pause
    return 0
  fi

  local jq_arg
  case "$type" in
    bool|int|number) jq_arg="--argjson" ;;
    *) jq_arg="--arg" ;;
  esac

  menu_spec_editor__session_backup_if_needed "$backup_job" || true
  menu_spec_editor__set_jq "$file" "$jq_arg" val "$v" "$json_path = \$val" || true
}

menu_spec_editor__template_index_locked_badge() {
  # Prints a group-level [ENV] badge if any field in the template is controlled by ENV.
  local template env_prefix idx field env_var
  template="$1"
  env_prefix="$2"
  idx="$3"

  while IFS= read -r field; do
    [[ -z "$field" ]] && continue
    env_var="${env_prefix}_${idx}_${field}"
    if menu_env_override_is_set "$env_var"; then
      printf " %s" "${C_RED}[ENV]${C_RESET}"
      return 0
    fi
  done < <(validation_list_template_fields "$template")

  return 0
}

menu_spec_editor__user_groups_edit_group() {
  local file g template env_prefix backup_job empty_label
  file="$1"
  g="$2"
  template="${3:-ENSHROUDED_ROLE}"
  env_prefix="${4:-ENSHROUDED_ROLE}"
  backup_job="${5:-manual:enshrouded}"
  empty_label="${6:-<empty>}"

  local base
  base=".userGroups[$g]"

  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    local current_name
    current_name="$(jq -r "$base.name | if . == null or . == \"\" then \"Group $g\" else . end" "$file" 2>/dev/null || echo "Group $g")"

    ui_header "User Group: $current_name"
    ui_note "Changes are written immediately."
    ui_note "[ENV] = controlled by container environment (locked)"
    echo

    local field_count last_group field env_var json_key json_path group label
    local -a fields
    fields=()
    field_count=0
    last_group=""

    while IFS= read -r field; do
      [[ -z "$field" ]] && continue

      env_var="${env_prefix}_${g}_${field}"
      json_key="$(validation_snake_to_lower_camel "$field")"
      json_path="${base}.${json_key}"
      label="$json_key"

      group="$(menu_editor_template_group_for_field "$template" "$field" 2>/dev/null || true)"
      if [[ "$group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${group:-Settings} ==${C_RESET}"
        last_group="$group"
      fi

      fields+=("$field")
      field_count=$((field_count + 1))

      printf "%s[%s]%s %-22s %s%s\n" \
        "${C_MAGENTA}" "$field_count" "${C_RESET}" "$label" \
        "$(menu_spec_editor__display_value_for_var "$file" "$env_var" "$json_path" "$empty_label")" \
        "$(menu_env_locked_badge "$env_var")"
    done < <(menu_editor_template_fields "$template")

    if [[ "$field_count" -le 0 ]]; then
      ui_warn_line "No role fields found in validation spec."
      ui_pause
      return 0
    fi

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    local choice
    choice="$(ui_prompt_choice "Field")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$field_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    field="${fields[$((choice - 1))]}"
    env_var="${env_prefix}_${g}_${field}"
    json_key="$(validation_snake_to_lower_camel "$field")"
    json_path="${base}.${json_key}"
    label="$json_key"

    local type empty_action bool_toggle
    type="$(validation_env_type "$env_var" 2>/dev/null || echo "string")"
    empty_action="cancel"
    bool_toggle="false"
    if [[ "$type" == "bool" ]]; then
      bool_toggle="true"
    fi
    if [[ "$field" == "PASSWORD" ]]; then
      empty_action="null"
      bool_toggle="false"
    fi

    menu_spec_editor__edit_var "$file" "" "$env_var" "$label" "$empty_action" "$backup_job" "$bool_toggle" "$json_path" || true
  done
}

menu_edit_user_groups_from_spec() {
  # Spec-driven editor for `.userGroups` driven by `templates.ENSHROUDED_ROLE`.
  local file template env_prefix backup_job empty_label
  file=""
  template="ENSHROUDED_ROLE"
  env_prefix="ENSHROUDED_ROLE"
  backup_job="manual:enshrouded"
  empty_label="<empty>"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file)
        file="${2-}"
        shift 2
        ;;
      --template)
        template="${2-}"
        shift 2
        ;;
      --envPrefix|--env-prefix)
        env_prefix="${2-}"
        shift 2
        ;;
      --backupJob|--backup-job)
        backup_job="${2-}"
        shift 2
        ;;
      --emptyLabel|--empty-label)
        empty_label="${2-}"
        shift 2
        ;;
      *)
        ui_warn_line "Unknown arg: $1"
        ui_pause
        return 1
        ;;
    esac
  done

  if [[ -z "$file" ]]; then
    ui_warn_line "menu_edit_user_groups_from_spec: missing --file"
    ui_pause
    return 1
  fi

  local choice count idx name
  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    ui_header "Edit User Groups"
    ui_note "[ENV] = controlled by container environment (locked)"

    count="$(jq -r '(.userGroups // []) | if type == "array" then length else 0 end' "$file" 2>/dev/null || echo 0)"
    if ! [[ "$count" =~ ^[0-9]+$ ]]; then
      count=0
    fi

    if [[ "$count" -le 0 ]]; then
      ui_warn_line "No userGroups found."
      echo
      ui_actions_bar "0 Back" "m Main" "x Exit"
      echo
      choice="$(ui_prompt_choice "Choice")"
      choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
      case "$choice" in
        0) return 0 ;;
        m) menu_nav_set "main"; return 0 ;;
        x|q) menu_nav_set "exit"; return 0 ;;
      esac
      continue
    fi

    local -a options
    options=()

    for idx in $(seq 0 $((count - 1))); do
      name="$(jq -r ".userGroups[$idx].name | if . == null or . == \"\" then \"Group $idx\" else . end" "$file" 2>/dev/null || echo "Group $idx")"
      options+=("$idx")
      printf "%s[%s]%s %s%s%s\n" \
        "${C_MAGENTA}" "$((idx + 1))" "${C_RESET}" \
        "${C_GREEN}" "$name" "${C_RESET}$(menu_spec_editor__template_index_locked_badge "$template" "$env_prefix" "$idx")"
    done

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    choice="$(ui_prompt_choice "Group")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    local g
    g=$((choice - 1))
    if [[ "$g" -lt 0 || "$g" -ge "$count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    menu_spec_editor__user_groups_edit_group "$file" "$g" "$template" "$env_prefix" "$backup_job" "$empty_label" || true
  done
}

menu_edit_json_from_spec() {
  # Interactive spec-driven editor.
  #
  # Required args:
  #   --title <title>
  #   --file <json_file>
  #   --metaField <meta_field>         # e.g. managerJsonPath, enshroudedMenuJsonPath, enshroudedJsonPath
  #
  # Optional args:
  #   --labelMode var|path             # how to render field labels (default: var)
  #   --labelStripPrefix <prefix>      # when labelMode=path, strip this prefix from the JSON path
  #   --filterPrefix <jsonPathPrefix>  # only include env values where jsonPath starts with this prefix
  #   --backupJob <supervisor_job>     # create one backup per edit session on first write
  #   --emptyAction cancel|null        # empty input behavior for scalar values (default: cancel)
  #   --boolToggle true|false          # allow empty input to toggle bools (default: false)
  #   --emptyLabel <text>              # placeholder for empty values (default: <empty>)
  #   --extra <token> <label> <group> <callback_fn>
  local title file meta_field label_mode label_strip_prefix filter_prefix backup_job empty_action bool_toggle empty_label
  title=""
  file=""
  meta_field=""
  label_mode="var"
  label_strip_prefix=""
  filter_prefix=""
  backup_job=""
  empty_action="cancel"
  bool_toggle="false"
  empty_label="<empty>"

  local -a extra_tokens extra_labels extra_groups extra_callbacks
  extra_tokens=()
  extra_labels=()
  extra_groups=()
  extra_callbacks=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        title="${2-}"
        shift 2
        ;;
      --file)
        file="${2-}"
        shift 2
        ;;
      --metaField|--meta-field|--meta)
        meta_field="${2-}"
        shift 2
        ;;
      --labelMode|--label-mode)
        label_mode="${2-}"
        shift 2
        ;;
      --labelStripPrefix|--label-strip-prefix)
        label_strip_prefix="${2-}"
        shift 2
        ;;
      --filterPrefix|--filter-prefix)
        filter_prefix="${2-}"
        shift 2
        ;;
      --backupJob|--backup-job)
        backup_job="${2-}"
        shift 2
        ;;
      --emptyAction|--empty-action)
        empty_action="${2-}"
        shift 2
        ;;
      --boolToggle|--bool-toggle)
        bool_toggle="${2-}"
        shift 2
        ;;
      --emptyLabel|--empty-label)
        empty_label="${2-}"
        shift 2
        ;;
      --extra)
        extra_tokens+=("${2-}")
        extra_labels+=("${3-}")
        extra_groups+=("${4-}")
        extra_callbacks+=("${5-}")
        shift 5
        ;;
      *)
        ui_warn_line "Unknown arg: $1"
        ui_pause
        return 1
        ;;
    esac
  done

  if [[ -z "$file" || -z "$meta_field" ]]; then
    ui_warn_line "menu_edit_json_from_spec: missing --file or --metaField"
    ui_pause
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      return 0
    fi

    ui_header "${title:-Edit Settings}"
    if declare -F menu_display_path >/dev/null 2>&1; then
      ui_kv "File" "$(menu_display_path "$file")"
    else
      ui_kv "File" "$file"
    fi
    ui_note "Changes are written immediately."
    ui_note "[ENV] = controlled by container environment (locked)"
    echo

    local field_count last_group var json_path group label
    local -a options
    options=()
    field_count=0
    last_group=""

    while IFS= read -r var; do
      [[ -z "$var" ]] && continue
      json_path="$(validation_env_meta_field "$var" "$meta_field" 2>/dev/null || true)"
      [[ -z "$json_path" ]] && continue

      if [[ -n "$filter_prefix" ]]; then
        case "$json_path" in
          "${filter_prefix}"*) ;;
          *) continue ;;
        esac
      fi

      group="$(menu_editor_group_for_env "$meta_field" "$var" 2>/dev/null || true)"
      case "$label_mode" in
        path)
          label="$json_path"
          if [[ -n "$label_strip_prefix" ]]; then
            label="${label#${label_strip_prefix}}"
          fi
          label="${label#.}"
          ;;
        *)
          label="$var"
          ;;
      esac

      if [[ "$group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${group:-Settings} ==${C_RESET}"
        last_group="$group"
      fi

      options+=("$var")
      field_count=$((field_count + 1))
      printf "%s[%s]%s %-26s %s%s\n" "${C_MAGENTA}" "$field_count" "${C_RESET}" "$label" "$(menu_spec_editor__display_value_for_var "$file" "$var" "$json_path" "$empty_label")" "$(menu_env_locked_badge "$var")"
    done < <(menu_editor_envs_for_meta_field "$meta_field")

    local i token extra_label extra_group cb
    for i in "${!extra_tokens[@]}"; do
      token="${extra_tokens[$i]}"
      extra_label="${extra_labels[$i]}"
      extra_group="${extra_groups[$i]}"
      cb="${extra_callbacks[$i]}"
      [[ -z "$token" || -z "$extra_label" || -z "$cb" ]] && continue

      if [[ "$extra_group" != "$last_group" ]]; then
        [[ -n "$last_group" ]] && echo
        echo "${C_DIM}== ${extra_group:-Settings} ==${C_RESET}"
        last_group="$extra_group"
      fi

      options+=("$token")
      field_count=$((field_count + 1))
      printf "%s[%s]%s %-26s %s\n" "${C_MAGENTA}" "$field_count" "${C_RESET}" "$extra_label" "${C_DIM}<enter>${C_RESET}"
    done

    if [[ "$field_count" -le 0 ]]; then
      ui_warn_line "No settings found in validation spec."
      ui_pause
      return 0
    fi

    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    local choice
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$field_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    local selected
    selected="${options[$((choice - 1))]}"

    # Extra entry?
    cb=""
    for i in "${!extra_tokens[@]}"; do
      if [[ "${extra_tokens[$i]}" == "$selected" ]]; then
        cb="${extra_callbacks[$i]}"
        break
      fi
    done

    if [[ -n "$cb" ]]; then
      "$cb" "$file" || true
      continue
    fi

    # Spec var.
    json_path="$(validation_env_meta_field "$selected" "$meta_field" 2>/dev/null || true)"
    case "$label_mode" in
      path)
        label="$json_path"
        if [[ -n "$label_strip_prefix" ]]; then
          label="${label#${label_strip_prefix}}"
        fi
        label="${label#.}"
        ;;
      *)
        label="$selected"
        ;;
    esac
    menu_spec_editor__edit_var "$file" "$meta_field" "$selected" "$label" "$empty_action" "$backup_job" "$bool_toggle" || true
  done
}


# --- inlined menu module: enshrouded ---
enshrouded_config_path() {
  printf "%s/enshrouded_server.json" "$install_path"
}

enshrouded_editor_jq_ok() {
  local file
  file="$1"
  jq -e 'type == "object"' "$file" >/dev/null 2>&1
}

enshrouded_editor_game_settings_menu() {
  local file
  file="$1"
  menu_edit_json_from_spec \
    --title "Edit Game Settings" \
    --file "$file" \
    --metaField "enshroudedJsonPath" \
    --labelMode "path" \
    --labelStripPrefix ".gameSettings." \
    --filterPrefix ".gameSettings." \
    --backupJob "manual:enshrouded" \
    --emptyAction "cancel" \
    --boolToggle "false" \
    --emptyLabel "<empty>"
}

enshrouded_editor_user_groups_menu() {
  local file
  file="$1"
  menu_edit_user_groups_from_spec \
    --file "$file" \
    --template "ENSHROUDED_ROLE" \
    --envPrefix "ENSHROUDED_ROLE" \
    --backupJob "manual:enshrouded" \
    --emptyLabel "<empty>"
}

editor_enshrouded_json() {
  local config_file backed_up
  config_file="$(enshrouded_config_path)"
  backed_up="false"

  if [[ ! -f "$config_file" ]]; then
    ui_warn_line "enshrouded_server.json is missing. Creating from profile..."
    ensure_enshrouded_config_from_profile || true
  fi

  if [[ ! -f "$config_file" ]] || ! enshrouded_editor_jq_ok "$config_file"; then
    ui_error "Invalid or missing config: $config_file"
    ui_pause
    return 1
  fi

  if ! menu_stop_server_for_config_change "edit Enshrouded settings"; then
    return 0
  fi

  menu_edit_json_from_spec \
    --title "Edit Enshrouded Settings" \
    --file "$config_file" \
    --metaField "enshroudedMenuJsonPath" \
    --labelMode "path" \
    --backupJob "manual:enshrouded" \
    --emptyAction "cancel" \
    --boolToggle "true" \
    --emptyLabel "<empty>" \
    --extra "__submenu_game_settings" "gameSettings (submenu)" "Game" "enshrouded_editor_game_settings_menu" \
    --extra "__submenu_user_groups" "userGroups (submenu)" "Access" "enshrouded_editor_user_groups_menu"
}

menu_profile_actions_after_change() {
  echo
  ui_note "Apply changes:"
  ui_opt 1 "Start/restart Enshrouded server"
  ui_opt 2 "Run bootstrap (recommended; does not start server)"
  ui_opt 0 "Back to menu"
  echo
  case "$(ui_prompt_number "Action")" in
    1)
      /usr/local/etc/enshrouded/jobs/cmd restart || true
      ui_success "Restart requested."
      ui_pause
      ;;
    2)
      /usr/local/etc/enshrouded/jobs/cmd bootstrap || true
      ui_success "Bootstrap started."
      ui_note "Note: bootstrap does not start the server."
      if menu_wait_for_program_exit "bootstrap" 600; then
        echo
        menu_prompt_start_server "Start server now?"
      else
        ui_note "Start the server later once bootstrap has finished."
      fi
      ui_pause
      ;;
    0) ;;
    *) ;;
  esac
}

menu_profile_label() {
  case "$1" in
    enshrouded) printf "Enshrouded" ;;
    manager) printf "Server Manager" ;;
    *) printf "Profile" ;;
  esac
}

menu_profile_config_file() {
  case "$1" in
    enshrouded) enshrouded_config_path ;;
    manager) manager_config_path ;;
    *) printf "" ;;
  esac
}

menu_profile_directory() {
  case "$1" in
    enshrouded) printf "%s" "$EN_PROFILE_DIR" ;;
    manager) printf "%s" "$MANAGER_PROFILE_TEMPLATE_DIR" ;;
    *) printf "" ;;
  esac
}

menu_profile_current_name() {
  case "$1" in
    enshrouded) enshrouded_profile_resolve ;;
    manager) manager_profile_resolve ;;
    *) printf "" ;;
  esac
}

menu_profile_list() {
  case "$1" in
    enshrouded) profiles_list_enshrouded | sort ;;
    manager) profiles_list_manager | sort ;;
    *) return 1 ;;
  esac
}

menu_run_profile_job() {
  local target action profile
  target="$1"
  action="$2"
  profile="$3"

  /usr/local/etc/enshrouded/jobs/cmd profile --target "$target" --action "$action" --profile "$profile" >/dev/null 2>&1
}

menu_apply_profile_flow() {
  local target label config_file profiles_dir profile_count idx selected profile
  target="$1"
  label="$(menu_profile_label "$target")"
  config_file="$(menu_profile_config_file "$target")"
  profiles_dir="$(menu_profile_directory "$target")"

  if ! menu_warn_env_overrides_before_profile_selection "$target"; then
    return 1
  fi

  local -a profiles
  mapfile -t profiles < <(menu_profile_list "$target")
  profile_count="${#profiles[@]}"
  if [[ "$profile_count" -eq 0 ]]; then
    ui_error "No ${label} profiles found in: $profiles_dir"
    ui_pause
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "Select ${label} Profile"
    ui_kv "Profiles Folder" "$profiles_dir"
    echo
    idx=1
    for p in "${profiles[@]}"; do
      printf "%s[%s]%s %s%s%s\n" "${C_MAGENTA}" "$idx" "${C_RESET}" "${C_GREEN}" "$p" "${C_RESET}"
      idx=$((idx + 1))
    done
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo

    selected="$(ui_prompt_choice "Profile")"
    selected="$(echo "$selected" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$selected" in
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
    esac

    if ! [[ "$selected" =~ ^[0-9]+$ ]] || [[ "$selected" -lt 1 || "$selected" -gt "$profile_count" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    profile="${profiles[$((selected - 1))]}"

    if checkRunning "server" || [[ -f "$config_file" ]]; then
      ui_warn_line "This will replace the active ${label} config with the selected profile."
      ui_warn_line "All players will be disconnected."
      echo
      ui_kv "Selected Profile" "$profile"
      ui_kv "Target File" "$config_file"
      echo
      if ! ui_confirm_yes_no "Stop server (if running) and apply this profile now?"; then
        ui_note "Cancelled."
        ui_pause
        continue
      fi
    fi

    if ! menu_run_profile_job "$target" "apply" "$profile"; then
      ui_warn_line "Failed to apply profile."
      ui_note "Check: cmd status"
      ui_pause
      continue
    fi

    ui_success "${label} profile applied: $profile"
    menu_profile_actions_after_change
    return 0
  done
}

menu_reset_profile_flow() {
  local target label profile config_file
  target="$1"
  label="$(menu_profile_label "$target")"
  config_file="$(menu_profile_config_file "$target")"
  profile="$(menu_profile_current_name "$target")"

  ui_header "Reset ${label} Profile"
  ui_warn_line "This resets $(basename "$config_file") from the currently selected profile."
  ui_warn_line "All players will be disconnected."
  echo
  ui_kv "Profile" "$profile"
  ui_kv "Target File" "$config_file"
  echo

  if ! ui_confirm_yes_no "Stop server (if running) and reset now?"; then
    ui_note "Cancelled."
    ui_pause
    return 0
  fi

  if ! menu_run_profile_job "$target" "reset" "$profile"; then
    ui_warn_line "Failed to reset profile."
    ui_note "Check: cmd status"
    ui_pause
    return 1
  fi

  ui_success "${label} profile reset completed: $profile"
  menu_profile_actions_after_change
  return 0
}

menu_profile_settings_menu() {
  local title target edit_fn choice
  title="$1"
  target="$2"
  edit_fn="$3"

  while :; do
    if menu_nav_is_set; then
      return 0
    fi
    ui_header "$title"
    ui_opt 1 "Edit current settings"
    ui_opt 2 "Reset current profile"
    ui_opt 3 "Select and apply profile"
    echo
    ui_actions_bar "0 Back" "m Main" "x Exit"
    echo
    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"
    case "$choice" in
      1)
        if declare -F "$edit_fn" >/dev/null 2>&1; then
          "$edit_fn"
        else
          ui_error "Missing editor function: $edit_fn"
          ui_pause
        fi
        ;;
      2) menu_reset_profile_flow "$target" || true ;;
      3) menu_apply_profile_flow "$target" || true ;;
      0) return 0 ;;
      m) menu_nav_set "main"; return 0 ;;
      x|q) menu_nav_set "exit"; return 0 ;;
      *)
        ui_warn_line "Invalid selection."
        ui_pause
        ;;
    esac
  done
}

menu_enshrouded_settings() { menu_profile_settings_menu "Enshrouded Server Settings" "enshrouded" "editor_enshrouded_json"; }


# --- inlined menu module: manager ---
editor_manager_json() {
  local config_file backed_up
  config_file="$(manager_config_path)"
  backed_up="false"

  if [[ ! -f "$config_file" ]] || ! jq -e 'type == "object"' "$config_file" >/dev/null 2>&1; then
    ui_warn_line "server_manager.json is missing or invalid. Initializing..."
    update_or_create_manager_config || true
  fi

  if [[ ! -f "$config_file" ]]; then
    ui_error "Could not find server_manager.json: $config_file"
    ui_pause
    return 1
  fi

  if ! menu_stop_server_for_config_change "edit Server Manager settings"; then
    return 0
  fi

  menu_edit_json_from_spec \
    --title "Edit Server Manager Settings" \
    --file "$config_file" \
    --metaField "managerJsonPath" \
    --labelMode "var" \
    --backupJob "manual:manager" \
    --emptyAction "null" \
    --boolToggle "false" \
    --emptyLabel "<null>"
}


menu_manager_settings() { menu_profile_settings_menu "Server Manager Settings" "manager" "editor_manager_json"; }


MENU_NAV=""
MENU_POST_HOOK_RAN="false"

run_menu_hook() {
  local hook_name hook_cmd
  hook_name="$1"
  hook_cmd="$2"
  if [[ -z "$hook_cmd" ]]; then
    return 0
  fi
  info "Running ${hook_name} hook: $hook_cmd"
  eval "$hook_cmd"
}

menu_run_post_hook_once() {
  if [[ "$MENU_POST_HOOK_RAN" == "true" ]]; then
    return 0
  fi
  MENU_POST_HOOK_RAN="true"
  if [[ -n "${MENU_SPEC_TMP_FILE:-}" ]]; then
    rm -f "$MENU_SPEC_TMP_FILE" 2>/dev/null || true
    MENU_SPEC_TMP_FILE=""
  fi
  run_menu_hook "menu post" "${MENU_POST_HOOK:-}"
}

menu_execute_action_by_type() {
  local action_name action_json action_type
  local requires_running confirm_raw confirm_message
  local cmd fn
  local -a internal_args cmd_args

  action_name="$1"
  action_json="$2"

  action_type="$(jq -r '.type // empty' <<<"$action_json" 2>/dev/null || true)"
  if [[ -z "$action_type" || "$action_type" == "null" ]]; then
    ui_warn_line "Action '${action_name}' has no valid type."
    ui_pause
    return 1
  fi

  requires_running="$(jq -r '(.requiresRunning // false) | tostring' <<<"$action_json" 2>/dev/null || echo "false")"
  if [[ "$requires_running" == "true" ]] && ! checkRunning "server"; then
    ui_warn_line "Action '${action_name}' requires the server to be running."
    ui_pause
    return 1
  fi

  confirm_raw="$(jq -r '
    if has("confirm") then
      if (.confirm | type) == "boolean" then
        (if .confirm then "true" else "false" end)
      elif (.confirm | type) == "string" then
        .confirm
      else
        "false"
      end
    else
      "false"
    end
  ' <<<"$action_json" 2>/dev/null || echo "false")"

  confirm_message=""
  if [[ "$confirm_raw" == "true" ]]; then
    confirm_message="Execute action '${action_name}'?"
  elif [[ "$confirm_raw" != "false" && -n "$confirm_raw" ]]; then
    confirm_message="$confirm_raw"
  fi

  if [[ -n "$confirm_message" ]]; then
    if ! ui_confirm_yes_no "$confirm_message"; then
      ui_note "Cancelled."
      ui_pause
      return 0
    fi
  fi

  case "$action_type" in
    cmd)
      cmd="$(jq -r '.cmd // empty' <<<"$action_json" 2>/dev/null || true)"
      if [[ -z "$cmd" || "$cmd" == "null" ]]; then
        ui_warn_line "Action '${action_name}' is missing 'cmd'."
        ui_pause
        return 1
      fi

      mapfile -t cmd_args < <(jq -r 'if (.args | type) == "array" then .args[] | tostring else empty end' <<<"$action_json" 2>/dev/null || true)
      ui_hr
      if [[ "${#cmd_args[@]}" -gt 0 ]]; then
        ui_note "Running: cmd $cmd ${cmd_args[*]}"
      else
        ui_note "Running: cmd $cmd"
      fi
      echo
      /usr/local/etc/enshrouded/jobs/cmd "$cmd" "${cmd_args[@]}" || true
      echo
      ui_pause
      ;;

    internal)
      fn="$(jq -r '.fn // empty' <<<"$action_json" 2>/dev/null || true)"
      if [[ -z "$fn" || "$fn" == "null" ]]; then
        ui_warn_line "Action '${action_name}' is missing 'fn'."
        ui_pause
        return 1
      fi

      if ! [[ "$fn" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        ui_warn_line "Invalid internal function name in action '${action_name}': $fn"
        ui_pause
        return 1
      fi

      if ! declare -F "$fn" >/dev/null 2>&1; then
        ui_warn_line "Internal function not found for action '${action_name}': $fn"
        ui_pause
        return 1
      fi

      mapfile -t internal_args < <(jq -r 'if (.args | type) == "array" then .args[] | tostring else empty end' <<<"$action_json" 2>/dev/null || true)
      "$fn" "${internal_args[@]}"
      ;;

    *)
      ui_warn_line "Unknown action type '${action_type}' for action '${action_name}'."
      ui_pause
      return 1
      ;;
  esac

  return 0
}

menu_dispatch_action() {
  local action_name action_json
  action_name="$1"

  if [[ ! -f "$MENU_SPEC_FILE" ]] || ! command -v jq >/dev/null 2>&1; then
    ui_error "Menu specification unavailable: ${MENU_SPEC_FILE}"
    ui_pause
    return 1
  fi

  action_json="$(jq -c --arg action "$action_name" '.actions[$action] // empty' "$MENU_SPEC_FILE" 2>/dev/null || true)"
  if [[ -z "$action_json" || "$action_json" == "null" ]]; then
    ui_warn_line "Unknown menu action: ${action_name}"
    ui_pause
    return 1
  fi

  menu_execute_action_by_type "$action_name" "$action_json"
}

menu_load_screen() {
  local screen title choice action
  local key label action_id nav_value
  local -a entries

  screen="$1"
  title="${2:-}"
  if [[ -z "$title" ]]; then
    if [[ "$screen" == "main" ]]; then
      title="Main Menu"
    else
      title="$screen"
    fi
  fi

  if [[ ! -f "$MENU_SPEC_FILE" ]] || ! command -v jq >/dev/null 2>&1; then
    ui_error "Menu specification unavailable: ${MENU_SPEC_FILE}"
    ui_pause
    menu_nav_set "exit"
    return 1
  fi

  while :; do
    if menu_nav_is_set; then
      nav_value="$(menu_nav_value)"
      case "$nav_value" in
        main)
          if [[ "$screen" == "main" ]]; then
            menu_nav_clear
          else
            return 0
          fi
          ;;
        exit)
          return 0
          ;;
      esac
    fi

    mapfile -t entries < <(jq -r --arg screen "$screen" '
      (.screens[$screen] // [])
      | map(select((.key // "") != "" and (.action // "") != ""))
      | .[]
      | "\(.key)|\((.title // .label // .action))|\(.action)"
    ' "$MENU_SPEC_FILE" 2>/dev/null || true)

    if [[ "${#entries[@]}" -eq 0 ]]; then
      ui_error "Menu screen '${screen}' missing or empty in ${MENU_SPEC_FILE}"
      ui_pause
      if [[ "$screen" == "main" ]]; then
        menu_nav_set "exit"
      fi
      return 1
    fi

    ui_header "$title"
    for action in "${entries[@]}"; do
      IFS='|' read -r key label action_id <<<"$action"
      [[ -z "$key" || -z "$action_id" ]] && continue
      ui_opt "$key" "$label"
    done
    echo

    if [[ "$screen" == "main" ]]; then
      ui_actions_bar "x Exit"
    else
      ui_actions_bar "0 Back" "m Main" "x Exit"
    fi
    echo

    choice="$(ui_prompt_choice "Choice")"
    choice="$(echo "$choice" | tr '[:upper:]' '[:lower:]' | xargs)"

    case "$choice" in
      x|q)
        if [[ "$screen" == "main" ]]; then
          ui_clear
        fi
        menu_nav_set "exit"
        return 0
        ;;
      0)
        if [[ "$screen" == "main" ]]; then
          ui_clear
          menu_nav_set "exit"
        fi
        return 0
        ;;
      m)
        if [[ "$screen" != "main" ]]; then
          menu_nav_set "main"
          return 0
        fi
        ;;
    esac

    action_id=""
    for action in "${entries[@]}"; do
      IFS='|' read -r key label action_id <<<"$action"
      [[ -z "$key" || -z "$action_id" ]] && continue
      if [[ "$key" == "$choice" ]]; then
        break
      fi
      action_id=""
    done

    if [[ -z "$action_id" ]]; then
      ui_warn_line "Invalid selection."
      ui_pause
      continue
    fi

    menu_dispatch_action "$action_id" || true
    if [[ "$MENU_ONCE" == "true" ]]; then
      return 0
    fi
  done
}

main() {
  parse_args "$@"
  init_runtime_env

  if ! menu_spec_init; then
    ui_error "Menu specification unavailable: ${MENU_SPEC_TSV_FILE}"
    exit 1
  fi

  trap menu_run_post_hook_once EXIT
  run_menu_hook "menu pre" "${MENU_PRE_HOOK:-}"
  if [[ "$MENU_START_SCREEN" == "main" ]]; then
    menu_load_screen "$MENU_START_SCREEN" "Main Menu"
  else
    menu_load_screen "$MENU_START_SCREEN"
  fi

  case "${MENU_NAV:-}" in
    exit)
      # On exit, offer to start the server if it is currently stopped.
      if ! checkRunning "server"; then
        ui_clear
        ui_banner
        ui_warn_line "The Enshrouded server is currently STOPPED."
        echo
        if ui_confirm_yes_no "Do you want me to start server before exiting?"; then
          ui_note "Starting server..."
          /usr/local/etc/enshrouded/jobs/cmd start >/dev/null 2>&1 || true
          ui_success "Start requested."
        else
          ui_note "Server remains stopped."
        fi
      fi
      ;;
  esac

  menu_run_post_hook_once
}

main "$@"

